#include <stdio.h>
#include <assert.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#define STR_LEN 64
#define LONG_STR 256
#define VERY_LONG_STR 65536

typedef struct 
{
    bool audio;
    bool video;
    bool input;
    bool render;
    char name[STR_LEN];
} Parms;

Parms parms;
const char* outDir = "out";

static void writeFile(const char* string, const char* relPath /* relative to outDir */)
{
    char str[STR_LEN];
    int r = sprintf(str, "%s/%s", outDir, relPath); 
    assert( r >= 0 );
    FILE* fp = fopen(str, "w");
    r = fputs(string, fp);
    assert( r >= 0 );
    r = fclose(fp);
    assert( r == 0 );
}

static void writeHeader(const char* header, const char* name)
{
    char outPath[STR_LEN];
    int r = sprintf(outPath, "%s.h", name); 
    assert( r >= 0 );
    writeFile(header, outPath);
    printf("Wrote %s header at %s\n", name, outPath);
}

static void writeSource(const char* source, const char* name)
{
    char outPath[STR_LEN];
    int r = sprintf(outPath, "%s.c", name); 
    assert( r >= 0 );
    writeFile(source, outPath);
    printf("Wrote %s source at %s\n", name, outPath);
}

static void writeModule(const char* src, const char* header, const char* name)
{
    writeHeader(header, name);
    writeSource(src, name);
}

void buildDirectories(void)
{
    const char dirs[][STR_LEN] = {
        "build",
        "shaders",
        "shaders/spv",
    };
    const int dirc = sizeof(dirs) / STR_LEN;
    struct stat st;
    for (int i = 0; i < dirc; i++) 
    { 
        char path[STR_LEN + 2]; // to make room for nul
        int r = sprintf(path, "%s/%s", outDir,  dirs[i]);
        assert( r >= 0 );
        if (stat(path, &st) == -1) // does not exist
            mkdir(path, 0700);
    }
}

void buildMakefile(void)
{
    char libs[LONG_STR] = "-lm ";
    char deps[LONG_STR] = " \\\n";
    char objs[LONG_STR] = " \\\n";
    if (parms.video)
    {
        strcat(libs, "-lvulkan -lxcb -lxcb-keysyms ");
        strcat(deps, "    d_display.h  \\\n");
        strcat(deps, "    v_video.h    \\\n");
        strcat(deps, "    v_def.h      \\\n");
        strcat(deps, "    v_memory.h   \\\n");
        strcat(deps, "    r_render.h   \\\n");
        strcat(deps, "    r_commands.h \\\n");
        strcat(deps, "    r_pipeline.h \\\n");
        strcat(objs, "    $(O)/d_display.o  \\\n");
        strcat(objs, "    $(O)/v_video.o    \\\n");
        strcat(objs, "    $(O)/v_memory.o   \\\n");
        strcat(objs, "    $(O)/r_render.o   \\\n");
        strcat(objs, "    $(O)/r_commands.o \\\n");
        strcat(objs, "    $(O)/r_pipeline.o \\\n");
    }
    if (parms.audio)
    {
        strcat(libs, "-lportaudio ");
        strcat(deps, "    a_audio.h    \\\n");
        strcat(objs, "    $(O)/a_audio.o \\\n");
    }
    if (parms.input)
    {
        strcat(deps, "    i_input.h    \\\n");
        strcat(objs, "    $(O)/i_input.o \\\n");
    }
    strcat(libs, "\n");
    strcat(deps,     "    m_math.h     \\\n");
    strcat(deps,     "    utils.h      \\\n");
    strcat(deps,     "    def.h        \\\n");
    strcat(objs,     "    $(O)/m_math.o     \\\n");
    strcat(objs,     "    $(O)/utils.o      \\\n");

    const char* mformat = 
    "CC = gcc\n"
    "CFLAGS = -Wall \n"
    "LIBS = %s\n" // libs
    "O = build\n"
    "GLSL = shaders\n"
    "SPV  = shaders/spv\n"
    //    "TOOL = tools\n"
    "\n"
    "NAME = %s\n" // name
    "\n"
    "DEPS = %s\n" // deps
    "\n"
    "OBJS = %s\n" // objs
    "\n"
    "SHADERS =                         \\\n"
    "		$(SPV)/default-vert.spv    \\\n"
    "		$(SPV)/default-frag.spv    \\\n"
    "\n"
    "\n"
    "debug: CFLAGS += -g -DVERBOSE=1\n"
    "debug: all\n"
    "\n"
    "release: CFLAGS += -DNDEBUG -O2\n"
    "release: all\n"
    "\n"
    "all: $(O)/$(NAME) tags\n"
    "\n"
    "shaders: $(SHADERS)\n"
    "\n"
    "clean: \n"
    "	rm -f $(O)/*\n"
    "\n"
    "tags:\n"
    "	ctags -R .\n"
    "\n"
    "$(O)/$(NAME): main.c $(OBJS) $(DEPS) shaders\n"
    "	$(CC) $(CFLAGS) $(OBJS) $< -o $@ $(LIBS)\n"
    "\n"
    "$(O)/%%.o:  %%.c $(DEPS)\n"
    "	$(CC) $(CFLAGS) -c $< -o $@\n"
    "\n"
    "$(SPV)/%%-vert.spv: $(GLSL)/%%.vert\n"
    "	glslc $< -o $@\n"
    "\n"
    "$(SPV)/%%-frag.spv: $(GLSL)/%%.frag\n"
    "	glslc $< -o $@\n";

    char makefile[VERY_LONG_STR]; 
    int r;
    r = sprintf(makefile, mformat, libs, parms.name, deps, objs);
    assert( r >= 0 ); 
    writeFile(makefile, "Makefile");
}

void buildMain(void)
{
    printf("Building main...\n");
    char vHeaders[LONG_STR] = "";
    char aHeaders[LONG_STR] = "";
    char iHeaders[LONG_STR] = "";
    char vInit[LONG_STR] =    "";
    char aInit[LONG_STR] =    "";
    char iInit[LONG_STR] =    "";
    char vCleanUp[STR_LEN] = "";
    char aCleanUp[STR_LEN] = "";
    char iCleanUp[STR_LEN] = "";
    if (parms.video)
    {
        strcat(vHeaders, "#include \"d_display.h\"\n");
        strcat(vHeaders, "#include \"v_video.h\"\n");
        strcat(vHeaders, "#include \"r_render.h\"\n");
        strcat(vHeaders, "#include \"r_commands.h\"\n");
        strcat(vInit,    "    d_Init();\n");
        strcat(vInit,    "    printf(\"Display initialized\\n\");\n");
        strcat(vInit,    "    v_Init();\n");
        strcat(vInit,    "    printf(\"Video initialized\\n\");\n");
        strcat(vInit,    "    r_Init();\n");
        strcat(vInit,    "    printf(\"Renderer initialized\\n\");\n");
        strcat(vCleanUp, "    r_CleanUp();\n");
        strcat(vCleanUp, "    v_CleanUp();\n");
        strcat(vCleanUp, "    d_CleanUp();\n");
    }
    if (parms.audio)
    {
        strcat(aHeaders, "#include \"a_audio.h\"\n");
        strcat(aInit,    "    a_Init();\n"); 
        strcat(aInit,    "    printf(\"Audio initialized\\n\");\n");
        strcat(aCleanUp, "    a_CleanUp();\n");
    }
    if (parms.input)
    {
        strcat(iHeaders, "#include \"i_input.h\"\n");
        strcat(iInit,    "    i_Init();\n"); 
        strcat(iInit,    "    printf(\"Input initialized\\n\");\n");
        strcat(iCleanUp, "    i_CleanUp();\n");
    }

    const char* mformat =
    "#include \"m_math.h\"\n"
    "#include \"utils.h\"\n"
    "#include \"def.h\"\n"
    "%s" // v headers
    "%s" // a headers
    "%s" // i headers
    "#include <stdio.h>\n"
    "#include <assert.h>\n"
    "#include <unistd.h>\n"
    "#include <time.h>\n"
    "\n"
    "jmp_buf exit_game;\n"
    "\n"
    "#define NS_TARGET 16666666 // 1 / 60 seconds\n"
    "//#define NS_TARGET 500000000\n"
    "#define NS_PER_S  1000000000\n"
    "\n"
    "int main(int argc, char *argv[])\n"
    "{\n"
    "%s" // a init
    "%s" // v init
    "%s" // i init
    "\n"
    "    struct timespec startTime = {0, 0};\n"
    "    struct timespec endTime = {0, 0};\n"
    "    struct timespec diffTime = {0, 0};\n"
    "    struct timespec remTime = {0, 0}; // this is just if we get signal interupted\n"
    "\n"
    "    uint64_t frameCount   = 0;\n"
    "    uint64_t nsTotal      = 0;\n"
    "    unsigned long nsDelta = 0;\n"
    "    uint32_t shortestFrame = NS_PER_S;\n"
    "    uint32_t longestFrame = 0;\n"
    "\n"
    "    r_InitRenderCommands();\n"
    "\n"
    "    while( 1 ) \n"
    "    {\n"
    "        if (setjmp(exit_game)) break;\n"
    "\n"
    "        clock_gettime(CLOCK_MONOTONIC, &startTime);\n"
    "\n"
    "\n"
    "        clock_gettime(CLOCK_MONOTONIC, &endTime);\n"
    "\n"
    "        nsDelta  = (endTime.tv_sec * NS_PER_S + endTime.tv_nsec) - (startTime.tv_sec * NS_PER_S + startTime.tv_nsec);\n"
    "        nsTotal += nsDelta;\n"
    "\n"
    "        if (nsDelta > longestFrame) longestFrame = nsDelta;\n"
    "        if (nsDelta < shortestFrame) shortestFrame = nsDelta;\n"
    "\n"
    "        diffTime.tv_nsec = NS_TARGET - nsDelta;\n"
    "\n"
    "        assert ( NS_TARGET > nsDelta );\n"
    "\n"
    "        nanosleep(&diffTime, &remTime);\n"
    "\n"
    "        frameCount++;\n"
    "    }\n"
    "\n"
    "\n"
    "\n"
    "%s" // i_CleanUp
    "%s" // v_CleanUp
    "%s" // a_CleanUp
    "    return 0;\n"
    "}\n";
    
    char mainString[VERY_LONG_STR];
    int r = sprintf(mainString, mformat, 
            vHeaders, aHeaders, iHeaders,  
            aInit, vInit, iInit,
            iCleanUp, vCleanUp, aCleanUp);
    assert( r >= 0 );
    writeSource(mainString, "main");
}

void buildGlobals(void)
{
    printf("Building Global files...\n");
    const char* defHeader =
    "#ifndef DEF_H\n"
    "#define DEF_H\n"
    "\n"
    "#include <stdio.h>\n"
    "#include <setjmp.h>\n"
    "\n"
    "#ifndef VERBOSE\n"
    "#define VERBOSE 1\n"
    "#endif\n"
    "\n"
    "#if VERBOSE > 0\n"
    "#define V1_PRINT(msg, args...) printf(msg, ## args)\n"
    "#else\n"
    "#define V1_PRINT(msg, args...)\n"
    "#endif\n"
    "\n"
    "#define WINDOW_WIDTH  1000\n"
    "#define WINDOW_HEIGHT 1000\n"
    "\n"
    "// key values are ascii lower case\n"
    "#define KEY_W     119\n"
    "#define KEY_A     97\n"
    "#define KEY_S     115\n"
    "#define KEY_D     100\n"
    "#define KEY_SPACE 32\n"
    "#define KEY_ESC   27\n"
    "\n"
    "extern jmp_buf exit_game;\n"
    "\n"
    "#endif /* end of include guard: DEF_H */\n";

    const char* utilsHeader =
    "#ifndef UTILS_H\n"
    "#define UTILS_H\n"
    "\n"
    "#include <stdio.h>\n"
    "#include \"m_math.h\"\n"
    "\n"
    "#define printBuffer(pBuffer, size, Type, printFn) { \\\n"
    "    const Type* util_pBuffer = (Type*)pBuffer; \\\n"
    "    for (int i = 0; i < size / sizeof(Type); i++) \\\n"
    "    { \\\n"
    "        printFn(&util_pBuffer[i]); \\\n"
    "    } \\\n"
    "} ;\n"
    "\n"
    "void printVec2(const Vec2*);\n"
    "void bitprint(const void *const thing, const size_t bitcount);\n"
    "\n"
    "#endif /* end of include guard: UTILS_H */\n";

    const char* utilsSource = 
    "#include \"utils.h\"\n"
    "#include <stdio.h>\n"
    "\n"
    "void printVec2(const Vec2* vec)\n"
    "{\n"
    "    printf(\"x: %f, y: %f\\n\", vec->x, vec->y);\n"
    "}\n"
    "\n"
    "void bitprint(const void* const thing, const size_t bitcount)\n"
    "{\n"
    "    int mask;\n"
    "    for (int i = bitcount - 1; i >= 0; i--) {\n"
    "        mask = 1 << i;   \n"
    "        if (mask & *(int*)thing)\n"
    "            putchar('1');\n"
    "        else\n"
    "            putchar('0');\n"
    "    }\n"
    "    putchar('\\n');\n"
    "}\n";

    const char* mathHeader = 
        "#ifndef M_MATH_H\n"
        "#define M_MATH_H\n"
        "\n"
        "#include <math.h>\n"
        "\n"
        "#define PI 3.141592653589793\n"
        "\n"
        "typedef struct {\n"
        "    float x;\n"
        "    float y;\n"
        "} Vec2;\n"
        "\n"
        "typedef struct {\n"
        "    float x;\n"
        "    float y;\n"
        "    float z;\n"
        "} Vec3;\n"
        "\n"
        "typedef struct {\n"
        "    float x00, x01, x10, x11;\n"
        "} Mat2;\n"
        "\n"
        "typedef struct {\n"
        "    Vec2 orig;\n"
        "    Vec2 dir;\n"
        "} Ray;\n"
        "\n"
        "typedef struct {\n"
        "    Vec2 A;\n"
        "    Vec2 B;\n"
        "} Segment;\n"
        "\n"
        "void m_Rotate(const float angle /* radians */, Vec2*);\n"
        "void m_Translate(const Vec2 t, Vec2*);\n"
        "void m_Scale(const float scale, Vec2*);\n"
        "void m_Add(const Vec2, Vec2*);\n"
        "Vec2 m_Subtract(const Vec2, const Vec2);\n"
        "//returns a random float between 0 and 1\n"
        "float m_Rand(void); \n"
        "//returns a random float between -1 and 1\n"
        "float m_RandNeg(void); \n"
        "float m_Length(const Vec2);\n"
        "float m_Length2(const Vec2);\n"
        "float m_Determinant(const Mat2);\n"
        "Vec2  m_PolarToCart(const float angle, const float radius);\n"
        "\n"
        "#endif /* end of include guard: M_MATH_H */\n";

    const char* mathSource = 
    "#include \"m_math.h\"\n"
    "#include <stdlib.h>\n"
    "#include <math.h>\n"
    "\n"
    "static void m_Mat2Vec2Mul(const Mat2* m, Vec2* v)\n"
    "{\n"
    "    float x = m->x00 * v->x + m->x01 * v->y;\n"
    "    v->y = m->x10 * v->x + m->x11 * v->y;\n"
    "    v->x = x;\n"
    "}\n"
    "\n"
    "void m_Rotate(const float angle, Vec2* v)\n"
    "{\n"
    "    Mat2 rot = {\n"
    "        .x00 = cos(angle),\n"
    "        .x01 = -sin(angle),\n"
    "        .x10 = sin(angle),\n"
    "        .x11 = cos(angle)\n"
    "    };\n"
    "    m_Mat2Vec2Mul(&rot, v);\n"
    "//    v->x = v->x * cos(angle) - v->y * sin(angle);\n"
    "//    v->y = v->x * sin(angle) + v->y * cos(angle);\n"
    "}\n"
    "\n"
    "void m_Translate(const Vec2 t, Vec2* v)\n"
    "{\n"
    "    v->x += t.x;\n"
    "    v->y += t.y;\n"
    "}\n"
    "\n"
    "void m_Scale(const float s, Vec2* v)\n"
    "{\n"
    "    v->x *= s;\n"
    "    v->y *= s;\n"
    "}\n"
    "\n"
    "float m_Length(const Vec2 v)\n"
    "{\n"
    "    return sqrt(m_Length2(v));\n"
    "}\n"
    "\n"
    "float m_Length2(const Vec2 v)\n"
    "{\n"
    "    return v.x * v.x + v.y * v.y;\n"
    "}\n"
    "\n"
    "void m_Add(const Vec2 v1, Vec2* v2)\n"
    "{\n"
    "    v2->x += v1.x;\n"
    "    v2->y += v1.y;\n"
    "}\n"
    "\n"
    "Vec2 m_Subtract(const Vec2 v1, const Vec2 v2)\n"
    "{\n"
    "    Vec2 v;\n"
    "    v.x = v1.x - v2.x;\n"
    "    v.y = v1.y - v2.y;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "float m_Rand(void)\n"
    "{\n"
    "    return rand() / (float)RAND_MAX;\n"
    "}\n"
    "\n"
    "float m_RandNeg(void)\n"
    "{\n"
    "    float r = rand() / (float)RAND_MAX;\n"
    "    return r * 2 - 1;\n"
    "}\n"
    "\n"
    "float m_Determinant(const Mat2 m)\n"
    "{\n"
    "    return m.x00 * m.x11 - m.x10 * m.x01;\n"
    "}\n"
    "\n"
    "Vec2 m_PolarToCart(const float angle, const float radius)\n"
    "{\n"
    "    Vec2 v = {\n"
    "        cos(angle) * radius,\n"
    "        sin(angle) * radius\n"
    "    };\n"
    "    return v;\n"
    "}\n";

    writeHeader(defHeader, "def");
    writeModule(mathSource, mathHeader, "m_math");
    writeModule(utilsSource, utilsHeader, "utils");
}

void buildAudioFiles(void)
{
    printf("Building Audio files...\n");
    const char* headerString = "";
    const char* sourceString =
    "#include \"a_audio.h\"\n"
    "#include <stdbool.h>\n"
    "#include <math.h>\n"
    "#include <portaudio.h>\n"
    "#include <assert.h>\n"
    "\n"
    "PaStream* a_Stream;\n"
    "Sound     soundA = {.duration = 2000};\n"
    "\n"
    "Wave      sineWave;\n"
    "Wave      squareWave;\n"
    "\n"
    "static int waveFunction(\n"
    "        const void*     inputBuffer,\n"
    "        void* restrict  outputBuffer,\n"
    "        unsigned long framesPerBuffer,\n"
    "        const PaStreamCallbackTimeInfo* timeInfo,\n"
    "        PaStreamCallbackFlags statusFlags,\n"
    "        void* restrict userData)\n"
    "{\n"
    "    Sound* data = (Sound*)userData;\n"
    "    float* out =   (float*)outputBuffer;\n"
    "    for (int i = 0; i < framesPerBuffer; i++) \n"
    "    {\n"
    "        const uint32_t ticks = data->ticks;\n"
    "        bool playing = ticks > 0;\n"
    "        if (playing)\n"
    "        {\n"
    "            float diff = (data->duration - ticks);\n"
    "            if (diff  < 100)  data->amplitude = diff  / 100.0;\n"
    "            if (ticks < 100)  data->amplitude = ticks / 100.0;\n"
    "            data->ticks--;\n"
    "        }\n"
    "        else \n"
    "            data->amplitude = 0.0;\n"
    "        const int spw = A_SAMPLE_RATE / data->frequency;\n"
    "        const int phaseVel = A_BUFFER_SIZE / spw;\n"
    "        *out++ = data->amplitude * data->wave.buffer[data->phase];\n"
    "        data->phase = (data->phase + phaseVel) % A_BUFFER_SIZE;\n"
    "    }\n"
    "    return 0;\n"
    "}\n"
    "\n"
    "static void initSineWave(void)\n"
    "{\n"
    "    double x = 0.0;\n"
    "    const double step = M_PI * 2 / A_BUFFER_SIZE;\n"
    "    for (int i = 0; i < A_BUFFER_SIZE; i++) \n"
    "    {\n"
    "        sineWave.buffer[i] = sin(x);\n"
    "        x += step;\n"
    "    }\n"
    "}\n"
    "\n"
    "void a_Init(void)\n"
    "{\n"
    "    PaError r;\n"
    "    initSineWave();\n"
    "    soundA.frequency = 420.0;\n"
    "    soundA.wave = sineWave;\n"
    "\n"
    "    r = Pa_Initialize();\n"
    "    assert( paNoError == r );\n"
    "\n"
    "    r = Pa_OpenDefaultStream(&a_Stream, \n"
    "                0, /*input channels*/\n"
    "                1,  /*output channels*/\n"
    "                paFloat32, /*sample format*/ \n"
    "                A_SAMPLE_RATE, \n"
    "                256, /*frames per buffer*/ \n"
    "                waveFunction, \n"
    "                &soundA);\n"
    "    assert( paNoError == r );\n"
    "    r = Pa_StartStream(a_Stream);\n"
    "    assert( paNoError == r );\n"
    "}\n"
    "\n"
    "void a_PlayBeep(void)\n"
    "{\n"
    "    soundA.ticks = soundA.duration;\n"
    "}\n"
    "\n"
    "void a_CleanUp(void)\n"
    "{\n"
    "    PaError r;\n"
    "    r = Pa_StopStream(a_Stream);\n"
    "    assert( paNoError == r );\n"
    "}\n";
}

void buildDisplayFiles(void)
{
    printf("Building Video files...\n");
    const char* headerString = 
    "/*\n"
    "d_display.c\n"
    "*/\n"
    "#ifndef D_INIT_H\n"
    "#define D_INIT_H\n"
    "\n"
    "#include <xcb/xcb.h>\n"
    "#include <xcb/xcb_keysyms.h>\n"
    "\n"
    "typedef struct {\n"
    "    xcb_connection_t* connection;\n"
    "    xcb_window_t      window;\n"
    "} D_XcbWindow;\n"
    "\n"
    "extern D_XcbWindow d_XcbWindow;\n"
    "\n"
    "void d_Init(void);\n"
    "void d_CleanUp(void);\n"
    "\n"
    "#endif /* end of include guard: D_INIT_H */\n";
    const char* sourceString =
    "#include \"d_display.h\"\n"
    "#include \"def.h\"\n"
    "#include <xcb/xcb.h>\n"
    "#include <xcb/xcb_keysyms.h>\n"
    "#include <xcb/xproto.h>\n"
    "#include <string.h>\n"
    "\n"
    "D_XcbWindow d_XcbWindow;\n"
    "\n"
    "static const char* windowName = \"floating\";\n"
    "\n"
    "void d_Init(void)\n"
    "{\n"
    "    int screenNum = 0;\n"
    "    d_XcbWindow.connection =     xcb_connect(NULL, &screenNum);\n"
    "    d_XcbWindow.window     =     xcb_generate_id(d_XcbWindow.connection);\n"
    "\n"
    "    const xcb_setup_t* setup = xcb_get_setup(d_XcbWindow.connection);\n"
    "    xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);\n"
    "\n"
    "    for (int i = 0; i < screenNum; i++)\n"
    "    {\n"
    "        xcb_screen_next(&iter);   \n"
    "    }\n"
    "\n"
    "    xcb_screen_t* screen = iter.data;\n"
    "\n"
    "    uint32_t values[2];\n"
    "    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;\n"
    "	values[0] = screen->black_pixel;\n"
    "//	we need to limit what events we are interested in.\n"
    "//	otherwise the queue will fill up with garbage\n"
    "	values[1] = //XCB_EVENT_MASK_EXPOSURE |\n"
    "//		XCB_EVENT_MASK_POINTER_MOTION |\n"
    "//		XCB_EVENT_MASK_ENTER_WINDOW |\n"
    "		XCB_EVENT_MASK_KEY_PRESS |\n"
    "        XCB_EVENT_MASK_KEY_RELEASE;\n"
    "//		XCB_EVENT_MASK_LEAVE_WINDOW |\n"
    "//		XCB_EVENT_MASK_BUTTON_PRESS |\n"
    "//		XCB_EVENT_MASK_BUTTON_RELEASE;\n"
    "//\n"
    "\n"
    "    xcb_create_window(d_XcbWindow.connection, \n"
    "            XCB_COPY_FROM_PARENT,              // depth \n"
    "            d_XcbWindow.window,                  // window id\n"
    "            screen->root,                      // parent\n"
    "            0, 0,                              // x and y coordinate of new window\n"
    "            WINDOW_WIDTH, WINDOW_HEIGHT, \n"
    "            0,                                 // border wdith \n"
    "            XCB_WINDOW_CLASS_COPY_FROM_PARENT, // class \n"
    "            XCB_COPY_FROM_PARENT,              // visual \n"
    "            mask, values);                          // masks (TODO: set to get inputs)\n"
    "\n"
    "    xcb_change_property(d_XcbWindow.connection, \n"
    "            XCB_PROP_MODE_REPLACE, \n"
    "            d_XcbWindow.window, \n"
    "            XCB_ATOM_WM_NAME, \n"
    "            XCB_ATOM_STRING, 8, strlen(windowName), windowName);\n"
    "\n"
    "    xcb_map_window(d_XcbWindow.connection, d_XcbWindow.window);\n"
    "    //xcb_flush(d_XcbWindow.connection);\n"
    "}\n"
    "\n"
    "void d_CleanUp(void)\n"
    "{\n"
    "    xcb_disconnect(d_XcbWindow.connection);\n"
    "}\n";
    writeModule(sourceString, headerString, "d_display");
}

void buildVideoFiles(void)
{
    printf("Building Video files...\n");
    const char* headerString = 
        "/*\n"
        "v_video.c\n"
        " */\n"
        "#ifndef V_VIDEO_H\n"
        "#define V_VIDEO_H\n"
        "\n"
        "#include \"v_def.h\"\n"
        "\n"
        "extern VkDevice         device;\n"
        "extern VkPhysicalDevice physicalDevice;\n"
        "extern uint32_t graphicsQueueFamilyIndex;\n"
        "extern VkQueue  graphicsQueues[G_QUEUE_COUNT];\n"
        "extern VkQueue  presentQueue;\n"
        "\n"
        "extern VkImage        swapchainImages[FRAME_COUNT];\n"
        "extern const VkFormat swapFormat;\n"
        "extern VkSwapchainKHR   swapchain;\n"
        "extern VkSemaphore    imageAcquiredSemaphores[FRAME_COUNT];\n"
        "extern uint64_t       frameCounter;\n"
        "\n"
        "void v_Init(void);\n"
        "void v_AcquireSwapImage(uint32_t* pImageIndex);\n"
        "void v_CleanUp(void);\n"
        "\n"
        "#endif /* end of include guard: V_VIDEO_H */\n";

    const char* sourceString =
        "#include \"def.h\"\n"
        "#include \"v_video.h\"\n"
        "#include \"v_memory.h\"\n"
        "#include \"d_display.h\"\n"
        "#include <stdio.h>\n"
        "#include <stdint.h>\n"
        "#include <assert.h>\n"
        "#include <string.h>\n"
        "\n"
        "#include <vulkan/vulkan_xcb.h>\n"
        "\n"
        "\n"
        "static VkInstance instance;\n"
        "\n"
        "VkDevice          device;\n"
        "VkPhysicalDevice  physicalDevice;\n"
        "\n"
        "uint32_t graphicsQueueFamilyIndex = UINT32_MAX; //hopefully this causes obvious errors\n"
        "VkQueue  graphicsQueues[G_QUEUE_COUNT];\n"
        "VkQueue  presentQueue;\n"
        "\n"
        "static VkSurfaceKHR     surface;\n"
        "VkSwapchainKHR   swapchain;\n"
        "\n"
        "VkImage        swapchainImages[FRAME_COUNT];\n"
        "const VkFormat swapFormat = VK_FORMAT_B8G8R8A8_SRGB;\n"
        "\n"
        "VkSemaphore    imageAcquiredSemaphores[FRAME_COUNT];\n"
        "uint64_t       frameCounter = 0;\n"
        "\n"
        "static VkDebugUtilsMessengerEXT debugMessenger;\n"
        "\n"
        "VkBool32 debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n"
        "        VkDebugUtilsMessageTypeFlagsEXT messageTypes,\n"
        "        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,\n"
        "        void* pUserData)\n"
        "{\n"
        "    V1_PRINT(\"%s\\n\", pCallbackData->pMessage);\n"
        "    return VK_FALSE; // application must return false;\n"
        "}\n"
        "\n"
        "static uint32_t getVkVersion(void)\n"
        "{\n"
        "    uint32_t v;\n"
        "    vkEnumerateInstanceVersion(&v);\n"
        "    uint32_t major = VK_VERSION_MAJOR(v);\n"
        "    uint32_t minor = VK_VERSION_MINOR(v);\n"
        "    uint32_t patch = VK_VERSION_PATCH(v);\n"
        "    V1_PRINT(\"Vulkan Version: %d.%d.%d\\n\", major, minor, patch);\n"
        "    return v;\n"
        "}\n"
        "\n"
        "static void inspectAvailableLayers(void)\n"
        "{\n"
        "    uint32_t availableCount;\n"
        "    vkEnumerateInstanceLayerProperties(&availableCount, NULL);\n"
        "    VkLayerProperties propertiesAvailable[availableCount];\n"
        "    vkEnumerateInstanceLayerProperties(&availableCount, propertiesAvailable);\n"
        "    V1_PRINT(\"%s\\n\", \"Vulkan Instance layers available:\");\n"
        "    const int padding = 90;\n"
        "    for (int i = 0; i < padding; i++) {\n"
        "        putchar('-');   \n"
        "    }\n"
        "    putchar('\\n');\n"
        "    for (int i = 0; i < availableCount; i++) {\n"
        "        const char* name = propertiesAvailable[i].layerName;\n"
        "        const char* desc = propertiesAvailable[i].description;\n"
        "        const int pad = padding - strlen(name);\n"
        "        V1_PRINT(\"%s%*s\\n\", name, pad, desc );\n"
        "        for (int i = 0; i < padding; i++) {\n"
        "            putchar('-');   \n"
        "        }\n"
        "        putchar('\\n');\n"
        "    }\n"
        "    putchar('\\n');\n"
        "}\n"
        "\n"
        "static void inspectAvailableExtensions(void)\n"
        "{\n"
        "    uint32_t availableCount;\n"
        "    vkEnumerateInstanceExtensionProperties(NULL, &availableCount, NULL);\n"
        "    VkExtensionProperties propertiesAvailable[availableCount];\n"
        "    vkEnumerateInstanceExtensionProperties(NULL, &availableCount, propertiesAvailable);\n"
        "    V1_PRINT(\"%s\\n\", \"Vulkan Instance extensions available:\");\n"
        "    for (int i = 0; i < availableCount; i++) {\n"
        "        V1_PRINT(\"%s\\n\", propertiesAvailable[i].extensionName);\n"
        "    }\n"
        "    putchar('\\n');\n"
        "}\n"
        "\n"
        "static void initVkInstance(void)\n"
        "{\n"
        "    uint32_t vulkver = getVkVersion();\n"
        "\n"
        "    const char appName[] =    \"Asteroids\"; \n"
        "    const char engineName[] = \"Sword\";\n"
        "\n"
        "    const VkApplicationInfo appInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n"
        "        .applicationVersion = 1.0,\n"
        "        .pApplicationName = appName,\n"
        "        .pEngineName = engineName,\n"
        "        .apiVersion = vulkver,\n"
        "    };\n"
        "\n"
        "#if VERBOSE > 1\n"
        "    inspectAvailableLayers();\n"
        "    inspectAvailableExtensions();\n"
        "#endif\n"
        "\n"
        "    // one for best practices\n"
        "    // second one is interesting, sounds like it allows\n"
        "    // V1_PRINT to be called from shaders.\n"
        "    const VkValidationFeatureEnableEXT valfeatures[] = {\n"
        "        VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,\n"
        "//        VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,\n"
        "//        VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT\n"
        "    };\n"
        "\n"
        "    const VkValidationFeaturesEXT extraValidation = {\n"
        "        .sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,\n"
        "        .disabledValidationFeatureCount = 0,\n"
        "        .enabledValidationFeatureCount = sizeof(valfeatures) / sizeof(VkValidationFeatureEnableEXT),\n"
        "        .pEnabledValidationFeatures = valfeatures\n"
        "    };\n"
        "\n"
        "    const char* enabledLayers[] =     {\n"
        "        \"VK_LAYER_KHRONOS_validation\"\n"
        "    };\n"
        "    const char* enabledExtensions[] = {\n"
        "        \"VK_KHR_surface\",\n"
        "        \"VK_KHR_xcb_surface\",\n"
        "        \"VK_EXT_debug_report\",\n"
        "        \"VK_EXT_debug_utils\"\n"
        "    };\n"
        "\n"
        "    const VkInstanceCreateInfo instanceInfo = {\n"
        "        .enabledLayerCount = sizeof(enabledLayers) / sizeof(char*),\n"
        "        .enabledExtensionCount = sizeof(enabledExtensions) / sizeof(char*),\n"
        "        .ppEnabledExtensionNames = enabledExtensions,\n"
        "        .ppEnabledLayerNames = enabledLayers,\n"
        "        .pApplicationInfo = &appInfo,\n"
        "        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n"
        "        .pNext = &extraValidation,\n"
        "    };\n"
        "\n"
        "    VkResult result = vkCreateInstance(&instanceInfo, NULL, &instance);\n"
        "    assert(result == VK_SUCCESS);\n"
        "    V1_PRINT(\"Successfully initialized Vulkan instance.\\n\");\n"
        "}\n"
        "\n"
        "static void initDebugMessenger(void)\n"
        "{\n"
        "    const VkDebugUtilsMessengerCreateInfoEXT ci = {\n"
        "        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,\n"
        "        .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT | \n"
        "                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |\n"
        "#if VERBOSE > 1\n"
        "                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |\n"
        "#endif\n"
        "                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,\n"
        "        .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |\n"
        "                       VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT |\n"
        "                       VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,\n"
        "        .pfnUserCallback = debugCallback,\n"
        "    };\n"
        "\n"
        "    PFN_vkVoidFunction fn;\n"
        "    fn = vkGetInstanceProcAddr(\n"
        "            instance, \n"
        "            \"vkCreateDebugUtilsMessengerEXT\");\n"
        "\n"
        "    assert(fn);\n"
        "\n"
        "    PFN_vkCreateDebugUtilsMessengerEXT func = (PFN_vkCreateDebugUtilsMessengerEXT)fn;\n"
        "\n"
        "    VkResult r = func(instance, \n"
        "            &ci, NULL, &debugMessenger);\n"
        "    assert(r == VK_SUCCESS);\n"
        "}\n"
        "\n"
        "static VkPhysicalDevice retrievePhysicalDevice(void)\n"
        "{\n"
        "    uint32_t physdevcount;\n"
        "    VkResult r = vkEnumeratePhysicalDevices(instance, &physdevcount, NULL);\n"
        "    assert(r == VK_SUCCESS);\n"
        "    VkPhysicalDevice devices[physdevcount];\n"
        "    r = vkEnumeratePhysicalDevices(instance, &physdevcount, devices);\n"
        "    assert(r == VK_SUCCESS);\n"
        "    VkPhysicalDeviceProperties props[physdevcount];\n"
        "    V1_PRINT(\"Physical device count: %d\\n\", physdevcount);\n"
        "    V1_PRINT(\"Physical device names:\\n\");\n"
        "    for (int i = 0; i < physdevcount; i++) \n"
        "    {\n"
        "        vkGetPhysicalDeviceProperties(devices[i], &props[i]);\n"
        "        V1_PRINT(\"%s\\n\", props[i].deviceName);\n"
        "    }\n"
        "    V1_PRINT(\"Selecting Device: %s\\n\", props[0].deviceName);\n"
        "    return devices[0];\n"
        "}\n"
        "\n"
        "static void initDevice(void)\n"
        "{\n"
        "    physicalDevice = retrievePhysicalDevice();\n"
        "    VkResult r;\n"
        "    uint32_t qfcount;\n"
        "\n"
        "    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &qfcount, NULL);\n"
        "\n"
        "    VkQueueFamilyProperties qfprops[qfcount];\n"
        "\n"
        "    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &qfcount, qfprops);\n"
        "\n"
        "    for (int i = 0; i < qfcount; i++) \n"
        "    {\n"
        "        VkQueryControlFlags flags = qfprops[i].queueFlags;\n"
        "        V1_PRINT(\"Queue Family %d: count: %d flags: \", i, qfprops[i].queueCount);\n"
        "        if (flags & VK_QUEUE_GRAPHICS_BIT)  V1_PRINT(\" Graphics \");\n"
        "        if (flags & VK_QUEUE_COMPUTE_BIT)   V1_PRINT(\" Compute \");\n"
        "        if (flags & VK_QUEUE_TRANSFER_BIT)  V1_PRINT(\" Tranfer \");\n"
        "        V1_PRINT(\"\\n\");\n"
        "    }\n"
        "\n"
        "    graphicsQueueFamilyIndex = 0; // because we know this\n"
        "    assert( G_QUEUE_COUNT < qfprops[graphicsQueueFamilyIndex].queueCount );\n"
        "\n"
        "    const float priorities[G_QUEUE_COUNT] = {1.0, 1.0, 1.0, 1.0};\n"
        "\n"
        "    const VkDeviceQueueCreateInfo qci[] = { \n"
        "        { \n"
        "            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n"
        "            .queueFamilyIndex = graphicsQueueFamilyIndex,\n"
        "            .queueCount = G_QUEUE_COUNT,\n"
        "            .pQueuePriorities = priorities,\n"
        "        }\n"
        "    };\n"
        "\n"
        "    uint32_t propCount;\n"
        "    r = vkEnumerateDeviceExtensionProperties(physicalDevice, NULL, &propCount, NULL);\n"
        "    assert(r == VK_SUCCESS);\n"
        "    VkExtensionProperties properties[propCount];\n"
        "    r = vkEnumerateDeviceExtensionProperties(physicalDevice, NULL, &propCount, properties);\n"
        "    assert(r == VK_SUCCESS);\n"
        "\n"
        "#if VERBOSE > 1\n"
        "    V1_PRINT(\"Device Extensions available: \\n\");\n"
        "    for (int i = 0; i < propCount; i++) \n"
        "    {\n"
        "        V1_PRINT(\"Name: %s    Spec Version: %d\\n\", properties[i].extensionName, properties[i].specVersion);    \n"
        "    }\n"
        "#endif\n"
        "\n"
        "    const char* extensions[] = {\n"
        "        VK_KHR_SWAPCHAIN_EXTENSION_NAME\n"
        "    };\n"
        "\n"
        "    VkPhysicalDeviceFeatures availableFeatures;\n"
        "    vkGetPhysicalDeviceFeatures(physicalDevice, &availableFeatures);\n"
        "\n"
        "    assert( VK_TRUE == availableFeatures.fillModeNonSolid );\n"
        "\n"
        "    VkPhysicalDeviceFeatures enabledFeatures = {\n"
        "        .fillModeNonSolid = VK_TRUE,\n"
        "        .wideLines = VK_TRUE,\n"
        "        .largePoints = VK_TRUE\n"
        "    };\n"
        "\n"
        "    const VkDeviceCreateInfo dci = {\n"
        "        .enabledLayerCount = 0,\n"
        "        .ppEnabledLayerNames = NULL,\n"
        "        .pEnabledFeatures = &enabledFeatures,\n"
        "        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,\n"
        "        .pQueueCreateInfos = qci,\n"
        "        .queueCreateInfoCount = sizeof(qci) / sizeof(qci[0]),\n"
        "        .enabledExtensionCount = 1,\n"
        "        .ppEnabledExtensionNames = extensions\n"
        "    };\n"
        "\n"
        "    r = vkCreateDevice(physicalDevice, &dci, NULL, &device);\n"
        "    assert(r == VK_SUCCESS);\n"
        "    V1_PRINT(\"Device created successfully.\\n\");\n"
        "}\n"
        "\n"
        "static void initQueues(void)\n"
        "{\n"
        "    for (int i = 0; i < G_QUEUE_COUNT; i++) \n"
        "    {\n"
        "        vkGetDeviceQueue(device, graphicsQueueFamilyIndex, i, &graphicsQueues[i]);\n"
        "    }\n"
        "    presentQueue = graphicsQueues[0]; // use the first queue to present\n"
        "}\n"
        "\n"
        "static void initSurface(void)\n"
        "{\n"
        "    const VkXcbSurfaceCreateInfoKHR ci = {\n"
        "        .sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,\n"
        "        .connection = d_XcbWindow.connection,\n"
        "        .window = d_XcbWindow.window,\n"
        "    };\n"
        "\n"
        "    VkResult r = vkCreateXcbSurfaceKHR(instance, &ci, NULL, &surface);\n"
        "    assert(r == VK_SUCCESS);\n"
        "    V1_PRINT(\"Surface created successfully.\\n\");\n"
        "}\n"
        "\n"
        "static void initSwapchain(void)\n"
        "{\n"
        "    VkBool32 supported;\n"
        "    vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, 0, surface, &supported);\n"
        "\n"
        "    assert(supported == VK_TRUE);\n"
        "\n"
        "    VkSurfaceCapabilitiesKHR capabilities;\n"
        "    VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &capabilities);\n"
        "    assert(r == VK_SUCCESS);\n"
        "\n"
        "    uint32_t formatsCount;\n"
        "    vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatsCount, NULL);\n"
        "    VkSurfaceFormatKHR surfaceFormats[formatsCount];\n"
        "    vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatsCount, surfaceFormats);\n"
        "\n"
        "    V1_PRINT(\"Surface formats: \\n\");\n"
        "    for (int i = 0; i < formatsCount; i++) {\n"
        "        V1_PRINT(\"Format: %d   Colorspace: %d\\n\", surfaceFormats[i].format, surfaceFormats[i].colorSpace);\n"
        "    }\n"
        "\n"
        "    uint32_t presentModeCount;\n"
        "    vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, NULL);\n"
        "    VkPresentModeKHR presentModes[presentModeCount];\n"
        "    vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, presentModes);\n"
        "\n"
        "    const VkPresentModeKHR presentMode = VK_PRESENT_MODE_FIFO_KHR; // i already know its supported \n"
        "\n"
        "    assert(capabilities.supportedUsageFlags & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);\n"
        "    V1_PRINT(\"Surface Capabilities: Min swapchain image count: %d\\n\", capabilities.minImageCount);\n"
        "\n"
        "    const VkSwapchainCreateInfoKHR ci = {\n"
        "        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,\n"
        "        .surface = surface,\n"
        "        .minImageCount = 2,\n"
        "        .imageFormat = swapFormat, //50\n"
        "        .imageColorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,\n"
        "        .imageExtent = capabilities.currentExtent,\n"
        "        .imageArrayLayers = 1, // number of views in a multiview / stereo surface\n"
        "        .imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,\n"
        "        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE, // queue sharing. see vkspec section 11.7. \n"
        "        .queueFamilyIndexCount = 0, // dont need with exclusive sharing\n"
        "        .pQueueFamilyIndices = NULL, // ditto\n"
        "        .preTransform = capabilities.currentTransform,\n"
        "        .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, //dunno. may affect blending\n"
        "        .presentMode = presentMode,\n"
        "        .clipped = VK_FALSE, // allows pixels convered by another window to be clipped. but will mess up saving the swap image.\n"
        "        .oldSwapchain = VK_NULL_HANDLE\n"
        "    };\n"
        "\n"
        "    r = vkCreateSwapchainKHR(device, &ci, NULL, &swapchain);\n"
        "    assert(VK_SUCCESS == r);\n"
        "\n"
        "    uint32_t imageCount;\n"
        "    r = vkGetSwapchainImagesKHR(device, swapchain, &imageCount, NULL);\n"
        "    assert(VK_SUCCESS == r);\n"
        "    assert(FRAME_COUNT == imageCount);\n"
        "    r = vkGetSwapchainImagesKHR(device, swapchain, &imageCount, swapchainImages);\n"
        "    assert(VK_SUCCESS == r);\n"
        "\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        VkSemaphoreCreateInfo semaCi = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};\n"
        "        r = vkCreateSemaphore(device, &semaCi, NULL, &imageAcquiredSemaphores[i]);\n"
        "    }\n"
        "\n"
        "    V1_PRINT(\"Swapchain created successfully.\\n\");\n"
        "}\n"
        "\n"
        "void v_Init(void)\n"
        "{\n"
        "    initVkInstance();\n"
        "    initDebugMessenger();\n"
        "    initDevice();\n"
        "    initQueues();\n"
        "    initSurface();\n"
        "    initSwapchain();\n"
        "    v_InitMemory();\n"
        "}\n"
        "\n"
        "void v_CleanUp(void)\n"
        "{\n"
        "    PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT)\n"
        "        vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\");\n"
        "        \n"
        "    v_CleanUpMemory();\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        vkDestroySemaphore(device, imageAcquiredSemaphores[i], NULL);\n"
        "    }\n"
        "    vkDestroySwapchainKHR(device, swapchain, NULL);\n"
        "    vkDestroySurfaceKHR(instance, surface, NULL);\n"
        "    vkDestroyDevice(device, NULL);\n"
        "    vkDestroyDebugUtilsMessengerEXT(instance, debugMessenger, NULL);\n"
        "    vkDestroyInstance(instance, NULL);\n"
        "}\n";

    const char* videoDefHeader = 
        "#ifndef V_DEF_H\n"
        "#define V_DEF_H\n"
        "\n"
        "#define VK_USE_PLATFORM_XCB_KHR\n"
        "#define FRAME_COUNT 2\n"
        "#define G_QUEUE_COUNT 4\n"
        "#define MAX_PIPELINES 4\n"
        "#define MAX_DESCRIPTOR_SETS 2\n"
        "\n"
        "#include <vulkan/vulkan.h>\n"
        "\n"
        "#endif /* end of include guard: V_DEF_H */\n"
        "\n";

    const char* videoMemoryHeader = 
        "#ifndef V_MEMORY_H\n"
        "#define V_MEMORY_H\n"
        "\n"
        "#include \"v_def.h\"\n"
        "#include <stdbool.h>\n"
        "\n"
        "typedef struct {\n"
        "    size_t       size;\n"
        "    uint8_t*     address;\n"
        "    VkDeviceSize vOffset;\n"
        "    VkBuffer*    vBuffer;\n"
        "    bool         isMapped;\n"
        "} V_block;\n"
        "\n"
        "extern uint8_t* hostBuffer;\n"
        "\n"
        "void v_InitMemory(void);\n"
        "\n"
        "V_block* v_RequestBlock(size_t size);\n"
        "\n"
        "void v_BindImageToMemory(const VkImage);\n"
        "\n"
        "void v_CleanUpMemory(void);\n"
        "\n"
        "#endif /* end of include guard: V_MEMORY_H */\n";

    const char* videoMemorySource = 
        "#include \"v_memory.h\"\n"
        "#include \"v_video.h\"\n"
        "#include \"def.h\"\n"
        "#include <stdio.h>\n"
        "#include <vulkan/vulkan_core.h>\n"
        "#include <assert.h>\n"
        "\n"
        "// HVC = Host Visible and Coherent\n"
        "#define MEMORY_SIZE_HVC 524288   // 512 KiB\n"
        "#define BUFFER_SIZE_HVC 262144   // 256 KiB\n"
        "// DL = Device Local    \n"
        "#define MEMORY_SIZE_DL  33554432 // 32 MiB\n"
        "#define MAX_BLOCKS 256\n"
        "\n"
        "static VkDeviceMemory memoryHostVisibleCoherent;\n"
        "static VkDeviceMemory memoryDeviceLocal;\n"
        "static VkBuffer       bufferHostMapped;\n"
        "uint8_t*              hostBuffer;\n"
        "\n"
        "static VkPhysicalDeviceMemoryProperties memoryProperties;\n"
        "static V_block blocks[MAX_BLOCKS];\n"
        "\n"
        "static int blockCount = 0;\n"
        "static int bytesAvailable = BUFFER_SIZE_HVC;\n"
        "static int curBufferOffset = 0;\n"
        "\n"
        "static void printBufferMemoryReqs(const VkMemoryRequirements* reqs)\n"
        "{\n"
        "    printf(\"Size: %ld\\tAlignment: %ld\\n\", reqs->size, reqs->alignment);\n"
        "}\n"
        "\n"
        "void v_InitMemory(void)\n"
        "{\n"
        "    VkResult r;\n"
        "\n"
        "    int hostVisibleCoherentTypeIndex;\n"
        "    int deviceLocalTypeIndex;\n"
        "\n"
        "    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties);\n"
        "\n"
        "    V1_PRINT(\"Memory Heap Info:\\n\");\n"
        "    for (int i = 0; i < memoryProperties.memoryHeapCount; i++) \n"
        "    {\n"
        "        V1_PRINT(\"Heap %d: Size %ld: %s local\\n\", \n"
        "                i,\n"
        "                memoryProperties.memoryHeaps[i].size, \n"
        "                memoryProperties.memoryHeaps[i].flags \n"
        "                & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT ? \"Device\" : \"Host\");\n"
        "                // note there are other possible flags, but seem to only deal with multiple gpus\n"
        "    }\n"
        "\n"
        "    bool foundHvc = false;\n"
        "    bool foundDl  = false;\n"
        "    V1_PRINT(\"Memory Type Info:\\n\");\n"
        "    for (int i = 0; i < memoryProperties.memoryTypeCount; i++) \n"
        "    {\n"
        "        VkMemoryPropertyFlags flags = memoryProperties.memoryTypes[i].propertyFlags;\n"
        "        V1_PRINT(\"Type %d: Heap Index: %d Flags: | %s%s%s%s%s%s\\n\", \n"
        "                i, \n"
        "                memoryProperties.memoryTypes[i].heapIndex,\n"
        "                flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ?  \"Device Local | \" : \"\",\n"
        "                flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ?  \"Host Visible | \" : \"\",\n"
        "                flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ? \"Host Coherent | \" : \"\",\n"
        "                flags & VK_MEMORY_PROPERTY_HOST_CACHED_BIT ?   \"Host Cached | \" : \"\",\n"
        "                flags & VK_MEMORY_PROPERTY_PROTECTED_BIT ?     \"Protected | \"   : \"\",\n"
        "                flags & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT ? \"Lazily allocated | \" : \"\"\n"
        "                );   \n"
        "        if ((flags & (VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)) &&\n"
        "                !foundHvc)\n"
        "        {\n"
        "            hostVisibleCoherentTypeIndex = i;\n"
        "            foundHvc = true;\n"
        "        }\n"
        "        if ((flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) && !foundDl)\n"
        "        {\n"
        "            deviceLocalTypeIndex = i;\n"
        "            foundDl = true;\n"
        "        }\n"
        "    }\n"
        "\n"
        "    assert( foundHvc );\n"
        "    assert( foundDl );\n"
        "\n"
        "    const VkMemoryAllocateInfo allocInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,\n"
        "        .allocationSize = MEMORY_SIZE_HVC,\n"
        "        .memoryTypeIndex = hostVisibleCoherentTypeIndex\n"
        "    };\n"
        "\n"
        "    r = vkAllocateMemory(device, &allocInfo, NULL, &memoryHostVisibleCoherent);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkBufferCreateInfo ci = {\n"
        "        .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n"
        "        .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | \n"
        "                 VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |\n"
        "                 VK_BUFFER_USAGE_INDEX_BUFFER_BIT,\n"
        "        .sharingMode = VK_SHARING_MODE_EXCLUSIVE, // queue determined by first use\n"
        "        .size = BUFFER_SIZE_HVC\n"
        "    };\n"
        "\n"
        "\n"
        "    r = vkCreateBuffer(device, &ci, NULL, &bufferHostMapped);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkMemoryRequirements reqs;\n"
        "    vkGetBufferMemoryRequirements(device, bufferHostMapped, &reqs);\n"
        "    // we dont need to check the reqs. spec states that \n"
        "    // any buffer created without SPARSITY flags will \n"
        "    // support being bound to host visible | host coherent\n"
        "\n"
        "    r = vkBindBufferMemory(device, bufferHostMapped, memoryHostVisibleCoherent, 0);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    r = vkMapMemory(device, memoryHostVisibleCoherent, 0, BUFFER_SIZE_HVC, 0, (void**)&hostBuffer);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    // --------------------------------------------------------\n"
        "    // allocate device local memory\n"
        "    // --------------------------------------------------------\n"
        "\n"
        "    const VkMemoryAllocateInfo allocInfoDl = {\n"
        "        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,\n"
        "        .allocationSize = MEMORY_SIZE_DL,\n"
        "        .memoryTypeIndex = deviceLocalTypeIndex\n"
        "    };\n"
        "\n"
        "    r = vkAllocateMemory(device, &allocInfoDl, NULL, &memoryDeviceLocal);\n"
        "    assert( VK_SUCCESS == r );\n"
        "}\n"
        "\n"
        "V_block* v_RequestBlock(const size_t size)\n"
        "{\n"
        "    assert( size % 4 == 0 ); // only allow for word-sized blocks\n"
        "    assert( size < bytesAvailable);\n"
        "    assert( blockCount < MAX_BLOCKS );\n"
        "    V_block* pBlock = &blocks[blockCount];\n"
        "    pBlock->address = hostBuffer + curBufferOffset;\n"
        "    pBlock->vBuffer = &bufferHostMapped;\n"
        "    pBlock->size = size;\n"
        "    pBlock->vOffset = curBufferOffset;\n"
        "    pBlock->isMapped = true;\n"
        "\n"
        "    bytesAvailable -= size;\n"
        "    curBufferOffset += size;\n"
        "    blockCount++;\n"
        "    // we really do need to be worrying about alignment here.\n"
        "    // anything that is not a multiple of 4 bytes will have issues.\n"
        "    // there is VERY GOOD CHANCE that there are other alignment\n"
        "    // issues to consider.\n"
        "    //\n"
        "    // we should probably divide up the buffer into Chunks, where\n"
        "    // all the blocks in a chunk contain the same kind of element\n"
        "    // (a chunk for vertices, a chunk for indices, a chunk for \n"
        "    // uniform matrices, etc).\n"
        "\n"
        "    return pBlock;\n"
        "}\n"
        "\n"
        "void v_BindImageToMemory(const VkImage image)\n"
        "{\n"
        "    static bool imageBound = false;\n"
        "    assert (!imageBound);\n"
        "    vkBindImageMemory(device, image, memoryDeviceLocal, 0);\n"
        "    imageBound = true;\n"
        "}\n"
        "\n"
        "void v_CleanUpMemory()\n"
        "{\n"
        "    vkUnmapMemory(device, memoryHostVisibleCoherent);\n"
        "    vkDestroyBuffer(device, bufferHostMapped, NULL);\n"
        "    vkFreeMemory(device, memoryHostVisibleCoherent, NULL);\n"
        "    vkFreeMemory(device, memoryDeviceLocal, NULL);\n"
        "};\n";

    writeModule(sourceString, headerString, "v_video");
    writeModule(videoMemorySource, videoMemoryHeader, "v_memory");
    writeHeader(videoDefHeader, "v_def");
}

void buildShaders(void)
{
    const char* vertstr = 
        "#version 460\n"
        "\n"
        "layout(location = 0) in vec2 pos;\n"
        "layout(location = 1) in vec3 color;\n"
        "\n"
        "layout(location = 0) out vec3 outColor;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    gl_Position = vec4(pos, 0.0, 1.0);\n"
        "    outColor = color;\n"
        "}\n";

    const char* fragstr = 
        "#version 460\n"
        "\n"
        "layout(location = 0) in  vec3 inColor;\n"
        "\n"
        "layout(location = 0) out vec4 outColor;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    outColor = vec4(inColor, 1);\n"
        "}\n";

    printf("Building shaders...\n");
    writeFile(vertstr, "shaders/default.vert");
    writeFile(fragstr, "shaders/default.frag");
    printf("Shaders built\n");
}

void buildRenderFiles(void)
{
    printf("Building Render files...\n");
    const char* renderSource = 
        "#include \"def.h\"\n"
        "#include \"r_render.h\"\n"
        "#include \"v_video.h\"\n"
        "#include \"v_memory.h\"\n"
        "#include \"r_pipeline.h\"\n"
        "#include \"utils.h\"\n"
        "#include <stdio.h>\n"
        "#include <stdint.h>\n"
        "#include <assert.h>\n"
        "#include <string.h>\n"
        "#include <vulkan/vulkan_core.h>\n"
        "\n"
        "\n"
        "VkRenderPass   swapchainRenderPass;\n"
        "VkRenderPass   offscreenRenderPass;\n"
        "\n"
        "FrameBuffer    offscreenFrameBuffer;\n"
        "\n"
        "const VkFormat colorFormat = VK_FORMAT_R8G8B8A8_SRGB;\n"
        "\n"
        "Frame          frames[FRAME_COUNT];\n"
        "uint32_t       curFrameIndex = 0;\n"
        "\n"
        "static void initFrames(void)\n"
        "{\n"
        "    VkResult r;\n"
        "    const VkCommandPoolCreateInfo cmdPoolCi = {\n"
        "        .queueFamilyIndex = graphicsQueueFamilyIndex,\n"
        "        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,\n"
        "    };\n"
        "\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        r = vkCreateCommandPool(device, &cmdPoolCi, NULL, &frames[i].commandPool);\n"
        "        assert(r == VK_SUCCESS);\n"
        "\n"
        "        const VkCommandBufferAllocateInfo allocInfo = {\n"
        "            .commandBufferCount = 1,\n"
        "            .commandPool = frames[i].commandPool,\n"
        "            .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,\n"
        "            .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO\n"
        "        };\n"
        "\n"
        "        r = vkAllocateCommandBuffers(device, &allocInfo, &frames[i].commandBuffer);\n"
        "        // spec states that the last parm is an array of commandBuffers... hoping a pointer\n"
        "        // to a single one works just as well\n"
        "        assert( VK_SUCCESS == r );\n"
        "\n"
        "        const VkSemaphoreCreateInfo semaCi = {\n"
        "            .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO\n"
        "        };\n"
        "\n"
        "        r = vkCreateSemaphore(device, &semaCi, NULL, &frames[i].semaphore);\n"
        "        assert( VK_SUCCESS == r );\n"
        "\n"
        "        const VkFenceCreateInfo fenceCi = {\n"
        "            .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,\n"
        "            .flags = VK_FENCE_CREATE_SIGNALED_BIT\n"
        "        };\n"
        "\n"
        "        r = vkCreateFence(device, &fenceCi, NULL, &frames[i].fence);\n"
        "        assert( VK_SUCCESS == r );\n"
        "\n"
        "        frames[i].index = i;\n"
        "        frames[i].pImage = &swapchainImages[i];\n"
        "\n"
        "        VkImageSubresourceRange ssr = {\n"
        "            .baseArrayLayer = 0,\n"
        "            .layerCount = 1,\n"
        "            .baseMipLevel = 0,\n"
        "            .levelCount = 1,\n"
        "            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT\n"
        "        };\n"
        "\n"
        "        VkImageViewCreateInfo imageViewInfo = {\n"
        "            .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n"
        "            .subresourceRange = ssr,\n"
        "            .format = swapFormat,\n"
        "            .viewType = VK_IMAGE_VIEW_TYPE_2D,\n"
        "            .image = *frames[i].pImage,\n"
        "        };\n"
        "\n"
        "        r = vkCreateImageView(device, &imageViewInfo, NULL, &frames[i].imageView);\n"
        "        assert( VK_SUCCESS == r );\n"
        "\n"
        "        frames[i].renderPass = swapchainRenderPass;\n"
        "    }\n"
        "    V1_PRINT(\"Frames successfully initialized.\\n\");\n"
        "}\n"
        "\n"
        "static void initRenderPasses(void)\n"
        "{\n"
        "    VkAttachmentDescription attachment = {\n"
        "        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,\n"
        "        .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,\n"
        "        .format = swapFormat,\n"
        "        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,\n"
        "        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,\n"
        "        .samples = VK_SAMPLE_COUNT_1_BIT, // TODO look into what this means\n"
        "    };\n"
        "\n"
        "    const VkAttachmentReference reference = {\n"
        "        .attachment = 0,\n"
        "        .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\n"
        "    };\n"
        "\n"
        "    const VkSubpassDescription subpass = {\n"
        "        .inputAttachmentCount = 0,\n"
        "        .preserveAttachmentCount = 0,\n"
        "        .colorAttachmentCount = 1,\n"
        "        .pColorAttachments    = &reference,\n"
        "        .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,\n"
        "    };\n"
        "\n"
        "    const VkSubpassDependency dependency = {\n"
        "        .srcSubpass = VK_SUBPASS_EXTERNAL,\n"
        "        .dstSubpass = 0,\n"
        "        .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n"
        "        .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n"
        "        .srcAccessMask = 0,\n"
        "        .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,\n"
        "    };\n"
        "\n"
        "    VkRenderPassCreateInfo ci = {\n"
        "        .subpassCount = 1,\n"
        "        .pSubpasses = &subpass,\n"
        "        .attachmentCount = 1,\n"
        "        .pAttachments = &attachment,\n"
        "        .dependencyCount = 1,\n"
        "        .pDependencies = &dependency,\n"
        "        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO\n"
        "    };\n"
        "\n"
        "    VkResult r = vkCreateRenderPass(device, &ci, NULL, &swapchainRenderPass);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    attachment.finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n"
        "    attachment.format      = colorFormat;\n"
        "\n"
        "    r = vkCreateRenderPass(device, &ci, NULL, &offscreenRenderPass);\n"
        "    assert( VK_SUCCESS == r );\n"
        "}\n"
        "\n"
        "static void initOffscreenFrameBuffer(void)\n"
        "{\n"
        "    VkImageCreateInfo imageInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,\n"
        "        .imageType = VK_IMAGE_TYPE_2D,\n"
        "        .format = colorFormat,\n"
        "        .extent = {WINDOW_WIDTH, WINDOW_HEIGHT, 1},\n"
        "        .mipLevels = 1,\n"
        "        .arrayLayers = 1,\n"
        "        .samples = VK_SAMPLE_COUNT_1_BIT,\n"
        "        .tiling = VK_IMAGE_TILING_OPTIMAL,\n"
        "        .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,\n"
        "        .sharingMode = VK_SHARING_MODE_EXCLUSIVE,\n"
        "        .queueFamilyIndexCount = 1,\n"
        "        .pQueueFamilyIndices = &graphicsQueueFamilyIndex,\n"
        "        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED\n"
        "    };\n"
        "\n"
        "    VkResult r;\n"
        "\n"
        "    r = vkCreateImage(device, &imageInfo, NULL, &offscreenFrameBuffer.image.handle);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkMemoryRequirements memReqs;\n"
        "    vkGetImageMemoryRequirements(device, offscreenFrameBuffer.image.handle, &memReqs);\n"
        "\n"
        "#ifndef NDEBUG\n"
        "    V1_PRINT(\"Offscreen framebuffer reqs: \\nSize: %ld\\nAlignment: %ld\\nTypes: \", \n"
        "            memReqs.size, memReqs.alignment);\n"
        "    bitprint(&memReqs.memoryTypeBits, 32);\n"
        "#endif\n"
        "\n"
        "    v_BindImageToMemory(offscreenFrameBuffer.image.handle);\n"
        "\n"
        "    VkImageViewCreateInfo viewInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n"
        "        .image = offscreenFrameBuffer.image.handle,\n"
        "        .viewType = VK_IMAGE_VIEW_TYPE_2D,\n"
        "        .components = {0, 0, 0, 0}, // no swizzling\n"
        "        .format = colorFormat,\n"
        "        .subresourceRange = {\n"
        "            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,\n"
        "            .baseMipLevel = 0,\n"
        "            .levelCount = 1,\n"
        "            .baseArrayLayer = 0,\n"
        "            .layerCount = 1\n"
        "        }\n"
        "    };\n"
        "\n"
        "    r = vkCreateImageView(device, &viewInfo, NULL, &offscreenFrameBuffer.image.view);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkSamplerCreateInfo samplerInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,\n"
        "        .magFilter = VK_FILTER_NEAREST,\n"
        "        .minFilter = VK_FILTER_NEAREST,\n"
        "        .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n"
        "        .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n"
        "        .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n"
        "        .mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST,\n"
        "        .mipLodBias = 0.0,\n"
        "        .anisotropyEnable = VK_FALSE,\n"
        "        .compareEnable = VK_FALSE,\n"
        "        .minLod = 0.0,\n"
        "        .maxLod = 0.0, // must both be 0 when using unnormalizedCoordinates\n"
        "        .borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,\n"
        "        .unnormalizedCoordinates = VK_TRUE // allow us to window coordinates in frag shader\n"
        "    };\n"
        "\n"
        "    r = vkCreateSampler(device, &samplerInfo, NULL, &offscreenFrameBuffer.image.sampler);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    offscreenFrameBuffer.pRenderPass = &offscreenRenderPass;\n"
        "\n"
        "    VkFramebufferCreateInfo framebufferInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,\n"
        "        .layers = 1,\n"
        "        .height = WINDOW_HEIGHT,\n"
        "        .width  = WINDOW_WIDTH,\n"
        "        .renderPass = *offscreenFrameBuffer.pRenderPass,\n"
        "        .attachmentCount = 1,\n"
        "        .pAttachments = &offscreenFrameBuffer.image.view,\n"
        "    };\n"
        "\n"
        "    r = vkCreateFramebuffer(device, &framebufferInfo, NULL, &offscreenFrameBuffer.handle);\n"
        "    assert( VK_SUCCESS == r );\n"
        "}\n"
        "\n"
        "static void initFrameBuffers(void)\n"
        "{\n"
        "    VkResult r;\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        const VkFramebufferCreateInfo ci = {\n"
        "            .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,\n"
        "            .layers = 1,\n"
        "            .renderPass = frames->renderPass,\n"
        "            .width = WINDOW_WIDTH,\n"
        "            .height = WINDOW_HEIGHT,\n"
        "            .attachmentCount = 1,\n"
        "            .pAttachments = &frames[i].imageView,\n"
        "        };\n"
        "\n"
        "        r = vkCreateFramebuffer(device, &ci, NULL, &frames[i].frameBuffer);\n"
        "        assert( VK_SUCCESS == r );\n"
        "    }\n"
        "\n"
        "    initOffscreenFrameBuffer();\n"
        "}\n"
        "\n"
        "void r_Init(void)\n"
        "{\n"
        "    initRenderPasses();\n"
        "    initFrames();\n"
        "    initFrameBuffers();\n"
        "    initDescriptorSets();\n"
        "    initDescriptors();\n"
        "    initPipelines();\n"
        "}\n"
        "\n"
        "void r_WaitOnQueueSubmit(void)\n"
        "{\n"
        "    vkWaitForFences(device, 1, &frames[curFrameIndex].fence, VK_TRUE, UINT64_MAX);\n"
        "}\n"
        "\n"
        "Frame* r_RequestFrame(void)\n"
        "{\n"
        "    VkResult r;\n"
        "    uint32_t i = frameCounter % FRAME_COUNT;\n"
        "    r = vkAcquireNextImageKHR(device, \n"
        "            swapchain, \n"
        "            UINT64_MAX, \n"
        "            imageAcquiredSemaphores[i], \n"
        "            VK_NULL_HANDLE, \n"
        "            &curFrameIndex);\n"
        "    assert(VK_SUCCESS == r);\n"
        "    frameCounter++;\n"
        "    return &frames[curFrameIndex];\n"
        "}\n"
        "\n"
        "void r_PresentFrame(void)\n"
        "{\n"
        "    VkResult res;\n"
        "\n"
        "    VkPipelineStageFlags stageFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;\n"
        "\n"
        "    VkSubmitInfo si = {\n"
        "        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n"
        "        .pWaitDstStageMask = &stageFlags,\n"
        "        .waitSemaphoreCount = 1,\n"
        "        .pWaitSemaphores = &imageAcquiredSemaphores[curFrameIndex],\n"
        "        .signalSemaphoreCount = 1,\n"
        "        .pSignalSemaphores = &frames[curFrameIndex].semaphore,\n"
        "        .commandBufferCount = 1,\n"
        "        .pCommandBuffers = &frames[curFrameIndex].commandBuffer,\n"
        "    };\n"
        "\n"
        "    vkWaitForFences(device, 1, &frames[curFrameIndex].fence, VK_TRUE, UINT64_MAX);\n"
        "    vkResetFences(device, 1, &frames[curFrameIndex].fence);\n"
        "\n"
        "    res = vkQueueSubmit(graphicsQueues[0], 1, &si, frames[curFrameIndex].fence);\n"
        "    assert( VK_SUCCESS == res );\n"
        "\n"
        "    VkResult r;\n"
        "    const VkPresentInfoKHR info = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,\n"
        "        .swapchainCount = 1,\n"
        "        .pSwapchains = &swapchain,\n"
        "        .waitSemaphoreCount = 1,\n"
        "        .pWaitSemaphores = &frames[curFrameIndex].semaphore,\n"
        "        .pResults = &r,\n"
        "        .pImageIndices = &curFrameIndex,\n"
        "    };\n"
        "\n"
        "    res = vkQueuePresentKHR(presentQueue, &info);\n"
        "    assert( VK_SUCCESS == r );\n"
        "    assert( VK_SUCCESS == res );\n"
        "}\n"
        "\n"
        "void r_CleanUp(void)\n"
        "{\n"
        "    cleanUpPipelines();\n"
        "    vkDestroySampler(device, offscreenFrameBuffer.image.sampler, NULL);\n"
        "    vkDestroyFramebuffer(device, offscreenFrameBuffer.handle, NULL);\n"
        "    vkDestroyImageView(device, offscreenFrameBuffer.image.view, NULL);\n"
        "    vkDestroyImage(device, offscreenFrameBuffer.image.handle, NULL);\n"
        "    vkDestroyRenderPass(device, swapchainRenderPass, NULL);\n"
        "    vkDestroyRenderPass(device, offscreenRenderPass, NULL);\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        vkDestroyFence(device, frames[i].fence, NULL);\n"
        "        vkDestroyImageView(device, frames[i].imageView, NULL);\n"
        "        vkDestroyFramebuffer(device, frames[i].frameBuffer, NULL);\n"
        "        vkDestroySemaphore(device, frames[i].semaphore, NULL);\n"
        "        vkDestroyCommandPool(device, frames[i].commandPool, NULL);\n"
        "    }\n"
        "}\n";

    const char* renderHeader = 
        "/*\n"
        "r_render.c\n"
        " */\n"
        "#ifndef R_INIT_H\n"
        "#define R_INIT_H\n"
        "\n"
        "#define VK_USE_PLATFORM_XCB_KHR\n"
        "\n"
        "#include \"v_def.h\"\n"
        "#include \"m_math.h\"\n"
        "\n"
        "typedef struct {\n"
        "    VkImage         handle;\n"
        "    VkImageView     view;\n"
        "    VkSampler       sampler;\n"
        "} Image;\n"
        "\n"
        "typedef struct {\n"
        "    VkFramebuffer   handle;\n"
        "    Image           image;\n"
        "    VkRenderPass*   pRenderPass;\n"
        "} FrameBuffer;\n"
        "\n"
        "typedef struct frame {\n"
        "    VkCommandPool   commandPool;\n"
        "    VkCommandBuffer commandBuffer;\n"
        "    VkSemaphore     semaphore;\n"
        "    VkFence         fence;\n"
        "    VkImage*        pImage;\n"
        "    VkImageView     imageView;\n"
        "    VkFramebuffer   frameBuffer;\n"
        "    VkRenderPass    renderPass;\n"
        "    uint32_t        index;\n"
        "} Frame;\n"
        "\n"
        "typedef struct {\n"
        "    Vec2 pos;\n"
        "    Vec3 color;\n"
        "} Vertex;\n"
        "\n"
        "extern VkPipeline pipelines[MAX_PIPELINES];\n"
        "extern VkRenderPass swapchainRenderPass;\n"
        "extern VkRenderPass offscreenRenderPass;\n"
        "extern Frame frames[FRAME_COUNT];\n"
        "extern uint32_t curFrameIndex;\n"
        "extern FrameBuffer offscreenFrameBuffer;\n"
        "\n"
        "void   r_Init(void);\n"
        "void   r_WaitOnQueueSubmit(void);\n"
        "Frame* r_RequestFrame(void);\n"
        "void   r_PresentFrame(void);\n"
        "void   r_CleanUp(void);\n"
        "\n"
        "#endif /* end of include guard: R_INIT_H */\n";

    const char* pipelineHeader = 
        "#ifndef R_PIPELINE_H\n"
        "#define R_PIPELINE_H\n"
        "\n"
        "#include \"v_def.h\"\n"
        "\n"
        "extern VkPipeline pipelines[MAX_PIPELINES];\n"
        "extern VkPipelineLayout pipelineLayoutPostProcess;\n"
        "\n"
        "extern VkDescriptorSet descriptorSets[MAX_DESCRIPTOR_SETS];\n"
        "\n"
        "enum {R_OBJ_PIPELINE, R_EMIT_PIPELINE, R_POST_PROC_PIPELINE};\n"
        "enum {R_POST_PROC_DESCRIPTOR_SET};\n"
        "\n"
        "void initDescriptorSets(void);\n"
        "void initDescriptors(void);\n"
        "void initPipelines(void);\n"
        "\n"
        "void cleanUpPipelines(void);\n"
        "\n"
        "#endif /* end of include guard: R_PIPELINE_H */\n"
        "\n";

    const char* pipelineSource = 
        "#include \"r_pipeline.h\"\n"
        "#include \"v_video.h\"\n"
        "#include \"r_render.h\"\n"
        "#include \"m_math.h\"\n"
        "#include \"def.h\"\n"
        "#include <stdio.h>\n"
        "#include <assert.h>\n"
        "#include <vulkan/vulkan_core.h>\n"
        "\n"
        "VkPipeline      pipelines[MAX_PIPELINES];\n"
        "VkDescriptorSet descriptorSets[MAX_DESCRIPTOR_SETS];\n"
        "static VkPipelineLayout pipelineLayoutGeometry;\n"
        "VkPipelineLayout pipelineLayoutPostProcess;\n"
        "static VkDescriptorSetLayout descriptorSetLayoutEmpty; \n"
        "static VkDescriptorSetLayout descriptorSetLayoutPostProcess; \n"
        "static VkDescriptorPool      descriptorPool;\n"
        "\n"
        "enum shaderStageType { VERT, FRAG };\n"
        "\n"
        "#define PIPELINE_COUNT 1\n"
        "#define DESCRIPTOR_SET_COUNT 1\n"
        "\n"
        "static void initShaderModule(const char* filepath, VkShaderModule* module)\n"
        "{\n"
        "    VkResult r;\n"
        "    int fr;\n"
        "    FILE* fp;\n"
        "    fp = fopen(filepath, \"rb\");\n"
        "    fr = fseek(fp, 0, SEEK_END);\n"
        "    assert( fr == 0 ); // success \n"
        "    size_t codeSize = ftell(fp);\n"
        "    rewind(fp);\n"
        "\n"
        "    unsigned char code[codeSize];\n"
        "    fread(code, 1, codeSize, fp);\n"
        "    fclose(fp);\n"
        "\n"
        "    const VkShaderModuleCreateInfo shaderInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n"
        "        .codeSize = codeSize,\n"
        "        .pCode = (uint32_t*)code,\n"
        "    };\n"
        "\n"
        "    r = vkCreateShaderModule(device, &shaderInfo, NULL, module);\n"
        "    assert( VK_SUCCESS == r );\n"
        "}\n"
        "\n"
        "void initDescriptorSets(void)\n"
        "{\n"
        "    VkResult r;\n"
        "\n"
        "    VkDescriptorSetLayoutCreateInfo layoutInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,\n"
        "        .bindingCount = 0,\n"
        "        .pBindings = NULL\n"
        "    };\n"
        "\n"
        "    r = vkCreateDescriptorSetLayout(device, &layoutInfo, NULL, &descriptorSetLayoutEmpty);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkDescriptorSetLayoutBinding textureBinding = {\n"
        "        .binding = 0,\n"
        "        .descriptorCount = 1,\n"
        "        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n"
        "        .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,\n"
        "        .pImmutableSamplers = NULL, // no one really seems to use these\n"
        "    };\n"
        "\n"
        "    layoutInfo.bindingCount = 1;\n"
        "    layoutInfo.pBindings = &textureBinding;\n"
        "\n"
        "    r = vkCreateDescriptorSetLayout(device, &layoutInfo, NULL, &descriptorSetLayoutPostProcess);\n"
        "    assert( VK_SUCCESS == r );\n"
        "\n"
        "    VkDescriptorPoolSize poolSize = {\n"
        "        .descriptorCount = 1,\n"
        "        .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\n"
        "    };\n"
        "\n"
        "    VkDescriptorPoolCreateInfo poolInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,\n"
        "        .maxSets = 1,\n"
        "        .poolSizeCount = 1,\n"
        "        // odd name. not the sizes of pools, but the numbers of descriptors\n"
        "        // of a certain type that can be created from the pool\n"
        "        .pPoolSizes = &poolSize, \n"
        "    };\n"
        "\n"
        "    vkCreateDescriptorPool(device, &poolInfo, NULL, &descriptorPool);\n"
        "\n"
        "    VkDescriptorSetAllocateInfo allocInfo = {\n"
        "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,\n"
        "        .descriptorPool = descriptorPool,\n"
        "        .descriptorSetCount = DESCRIPTOR_SET_COUNT,\n"
        "        .pSetLayouts = &descriptorSetLayoutPostProcess,\n"
        "    };\n"
        "\n"
        "    vkAllocateDescriptorSets(device, &allocInfo, descriptorSets);\n"
        "}\n"
        "\n"
        "void initDescriptors(void)\n"
        "{\n"
        "    VkDescriptorImageInfo imageInfo = {\n"
        "        .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n"
        "        .imageView = offscreenFrameBuffer.image.view,\n"
        "        .sampler = offscreenFrameBuffer.image.sampler\n"
        "    };\n"
        "\n"
        "    VkWriteDescriptorSet writeImages = {\n"
        "        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n"
        "        .dstArrayElement = 0,\n"
        "        .dstSet = descriptorSets[R_POST_PROC_DESCRIPTOR_SET],\n"
        "        .dstBinding = 0,\n"
        "        .descriptorCount = 1,\n"
        "        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n"
        "        .pImageInfo = &imageInfo\n"
        "    };\n"
        "\n"
        "    vkUpdateDescriptorSets(device, 1, &writeImages, 0, NULL);\n"
        "}\n"
        "\n"
        "static void initPipelineLayouts(void)\n"
        "{\n"
        "    VkResult r;\n"
        "    VkPipelineLayoutCreateInfo info = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n"
        "        .pNext = NULL,\n"
        "        .flags = 0,\n"
        "        .setLayoutCount = 1, // ?\n"
        "        .pSetLayouts = &descriptorSetLayoutEmpty,\n"
        "        .pushConstantRangeCount = 0,\n"
        "        .pPushConstantRanges = NULL\n"
        "    };\n"
        "\n"
        "    r = vkCreatePipelineLayout(device, &info, NULL, &pipelineLayoutGeometry);\n"
        "    assert( VK_SUCCESS == r );\n"
        "}\n"
        "\n"
        "void initPipelines(void)\n"
        "{\n"
        "    initPipelineLayouts();\n"
        "\n"
        "    VkShaderModule vertModule;\n"
        "    VkShaderModule fragModule;\n"
        "\n"
        "    initShaderModule(\"shaders/spv/default-vert.spv\", &vertModule);\n"
        "    initShaderModule(\"shaders/spv/default-frag.spv\", &fragModule);\n"
        "\n"
        "    const VkSpecializationInfo shaderSpecialInfo = {\n"
        "        // TODO\n"
        "    };\n"
        "\n"
        "    const VkPipelineShaderStageCreateInfo shaderStages[2] = {\n"
        "        [0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n"
        "        [0].stage = VK_SHADER_STAGE_VERTEX_BIT,\n"
        "        [0].module = vertModule,\n"
        "        [0].pName = \"main\",\n"
        "        [0].pSpecializationInfo = NULL,\n"
        "        [1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n"
        "        [1].stage = VK_SHADER_STAGE_FRAGMENT_BIT,\n"
        "        [1].module = fragModule,\n"
        "        [1].pName = \"main\",\n"
        "        [1].pSpecializationInfo = NULL,\n"
        "    }; // vert and frag\n"
        "\n"
        "    const VkVertexInputBindingDescription bindingDescription = {\n"
        "        .binding = 0,\n"
        "        .stride  = sizeof(Vertex), // all our verts will be 2D\n"
        "        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX\n"
        "    };\n"
        "\n"
        "    const VkVertexInputAttributeDescription positionAttributeDescription = {\n"
        "        .binding = 0,\n"
        "        .location = 0, \n"
        "        .format = VK_FORMAT_R32G32_SFLOAT,\n"
        "        .offset = 0,\n"
        "    };\n"
        "\n"
        "    const VkVertexInputAttributeDescription colorAttributeDescription = {\n"
        "        .binding = 0,\n"
        "        .location = 1, \n"
        "        .format = VK_FORMAT_R32G32B32_SFLOAT,\n"
        "        .offset = sizeof(Vec2),\n"
        "    };\n"
        "\n"
        "    VkVertexInputAttributeDescription vAttrDescs[2] = {\n"
        "        positionAttributeDescription, colorAttributeDescription\n"
        "    };\n"
        "\n"
        "    const VkPipelineVertexInputStateCreateInfo vertexInput = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,\n"
        "        .vertexBindingDescriptionCount = 1,\n"
        "        .pVertexBindingDescriptions = &bindingDescription,\n"
        "        .vertexAttributeDescriptionCount = 2,\n"
        "        .pVertexAttributeDescriptions = vAttrDescs \n"
        "    };\n"
        "\n"
        "    const VkPipelineInputAssemblyStateCreateInfo inputAssembly = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,\n"
        "        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,\n"
        "        .primitiveRestartEnable = VK_FALSE // applies only to index calls\n"
        "    };\n"
        "\n"
        "    const VkViewport viewport = {\n"
        "        .height = WINDOW_HEIGHT,\n"
        "        .width = WINDOW_WIDTH,\n"
        "        .x = 0,\n"
        "        .y = 0,\n"
        "        .minDepth = 0.0,\n"
        "        .maxDepth = 1.0\n"
        "    };\n"
        "\n"
        "    const VkRect2D scissor = {\n"
        "        .extent = {WINDOW_WIDTH, WINDOW_HEIGHT},\n"
        "        .offset = {0, 0}\n"
        "    };\n"
        "\n"
        "    const VkPipelineViewportStateCreateInfo viewportState = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,\n"
        "        .scissorCount = 1,\n"
        "        .pScissors = &scissor,\n"
        "        .viewportCount = 1,\n"
        "        .pViewports = &viewport,\n"
        "    };\n"
        "\n"
        "    const VkPipelineRasterizationStateCreateInfo rasterizationState = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,\n"
        "        .depthClampEnable = VK_FALSE, // dunno\n"
        "        .rasterizerDiscardEnable = VK_FALSE, // actually discards everything\n"
        "        .polygonMode = VK_POLYGON_MODE_FILL,\n"
        "        .cullMode = VK_CULL_MODE_BACK_BIT,\n"
        "        .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,\n"
        "        .depthBiasEnable = VK_FALSE,\n"
        "        .lineWidth = 1.0\n"
        "    };\n"
        "\n"
        "    const VkPipelineMultisampleStateCreateInfo multisampleState = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,\n"
        "        .sampleShadingEnable = VK_FALSE,\n"
        "        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT\n"
        "        // TODO: alot more settings here. more to look into\n"
        "    };\n"
        "\n"
        "    const VkPipelineColorBlendAttachmentState attachmentState = {\n"
        "        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | \n"
        "            VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT, /* need this to actually\n"
        "                                                                    write anything to the\n"
        "                                                                    framebuffer */\n"
        "        .blendEnable = VK_FALSE, // no blending for now\n"
        "        .srcColorBlendFactor = 0,\n"
        "        .dstColorBlendFactor = 0,\n"
        "        .colorBlendOp = 0,\n"
        "        .srcAlphaBlendFactor = 0,\n"
        "        .dstAlphaBlendFactor = 0,\n"
        "        .alphaBlendOp = 0,\n"
        "    };\n"
        "\n"
        "    const VkPipelineColorBlendStateCreateInfo colorBlendState = {\n"
        "        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,\n"
        "        .logicOpEnable = VK_FALSE, // only for integer framebuffer formats\n"
        "        .logicOp = 0,\n"
        "        .attachmentCount = 1,\n"
        "        .pAttachments = &attachmentState /* must have independentBlending device   \n"
        "            feature enabled for these to be different. each entry would correspond \n"
        "            to the blending for a different framebuffer. */\n"
        "    };\n"
        "\n"
        "    const VkGraphicsPipelineCreateInfo pipelineInfo = {\n"
        "        .basePipelineIndex = 0, // not used\n"
        "        .basePipelineHandle = 0,\n"
        "        .subpass = 0, // which subpass in the renderpass do we use this pipeline with\n"
        "        .renderPass = swapchainRenderPass,\n"
        "        .layout = pipelineLayoutGeometry,\n"
        "        .pDynamicState = NULL,\n"
        "        .pColorBlendState = &colorBlendState,\n"
        "        .pDepthStencilState = NULL,\n"
        "        .pMultisampleState = &multisampleState,\n"
        "        .pRasterizationState = &rasterizationState,\n"
        "        .pViewportState = &viewportState,\n"
        "        .pTessellationState = NULL, // may be able to do splines with this\n"
        "        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n"
        "        .flags = 0,\n"
        "        .stageCount = sizeof(shaderStages) / sizeof(shaderStages[0]),\n"
        "        .pStages = shaderStages,\n"
        "        .pVertexInputState = &vertexInput,\n"
        "        .pInputAssemblyState = &inputAssembly,\n"
        "    };\n"
        "\n"
        "    VkGraphicsPipelineCreateInfo infos[PIPELINE_COUNT] = {pipelineInfo};\n"
        "\n"
        "    vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, PIPELINE_COUNT, infos, NULL, pipelines);\n"
        "\n"
        "    vkDestroyShaderModule(device, vertModule, NULL);\n"
        "    vkDestroyShaderModule(device, fragModule, NULL);\n"
        "    vkDestroyDescriptorSetLayout(device, descriptorSetLayoutEmpty, NULL);\n"
        "    vkDestroyDescriptorSetLayout(device, descriptorSetLayoutPostProcess, NULL);\n"
        "}\n"
        "\n"
        "void cleanUpPipelines()\n"
        "{\n"
        "    vkDestroyPipelineLayout(device, pipelineLayoutGeometry, NULL);\n"
        "    vkDestroyPipelineLayout(device, pipelineLayoutPostProcess, NULL);\n"
        "    for (int i = 0; i < PIPELINE_COUNT; i++) \n"
        "    {\n"
        "        vkDestroyPipeline(device, pipelines[i], NULL);\n"
        "    }\n"
        "    vkDestroyDescriptorPool(device, descriptorPool, NULL);\n"
        "}\n";

    const char* commandsHeader =
        "#ifndef R_COMMANDS_H\n"
        "#define R_COMMANDS_H\n"
        "\n"
        "void r_InitRenderCommands(void);\n"
        "void r_UpdateRenderCommands(void);\n"
        "\n"
        "#endif /* end of include guard: R_COMMANDS_H */\n";

    const char* commandsSource = 
        "#include \"r_commands.h\"\n"
        "#include \"r_render.h\"\n"
        "#include \"v_video.h\"\n"
        "#include \"r_pipeline.h\"\n"
        "#include \"v_memory.h\"\n"
        "#include \"def.h\"\n"
        "#include <assert.h>\n"
        "#include <vulkan/vulkan_core.h>\n"
        "\n"
        "static V_block* vertexBlock;\n"
        "static Vertex*  vertices;\n"
        "\n"
        "static void createTriangle(void)\n"
        "{\n"
        "    // Create vertex buffer\n"
        "\n"
        "    vertexBlock = v_RequestBlock(sizeof(Vertex) * 3);\n"
        "    vertices = (Vertex*)vertexBlock->address;\n"
        "\n"
        "    // make triangle\n"
        "\n"
        "    vertices[0].pos.x =  0.0;\n"
        "    vertices[0].pos.y = -0.5;\n"
        "\n"
        "    vertices[1].pos.x = -0.5;\n"
        "    vertices[1].pos.y =  0.5;\n"
        "\n"
        "    vertices[2].pos.x =  0.5;\n"
        "    vertices[2].pos.y =  0.5;\n"
        "\n"
        "    // colors of hydrogen atom spectral lines\n"
        "    // bahmer series for n = 3, 4, 5\n"
        "    vertices[0].color.x =  1.0;\n"
        "    vertices[0].color.y =  0.0;\n"
        "    vertices[0].color.z =  0.0;\n"
        "\n"
        "    vertices[1].color.x =  0.0;\n"
        "    vertices[1].color.y =  0.93725;\n"
        "    vertices[1].color.z =  1.0;\n"
        "\n"
        "    vertices[2].color.x =  0.15686;\n"
        "    vertices[2].color.y =  0.0;\n"
        "    vertices[2].color.z =  1.0;\n"
        "\n"
        "}\n"
        "\n"
        "void r_InitRenderCommands(void)\n"
        "{\n"
        "    createTriangle();\n"
        "\n"
        "    for (int i = 0; i < FRAME_COUNT; i++) \n"
        "    {\n"
        "        r_RequestFrame();\n"
        "        \n"
        "        r_UpdateRenderCommands();\n"
        "\n"
        "        r_PresentFrame();\n"
        "    }\n"
        "\n"
        "}\n"
        "\n"
        "void r_UpdateRenderCommands(void)\n"
        "{\n"
        "    VkResult r;\n"
        "    Frame* frame = &frames[curFrameIndex];\n"
        "    vkResetCommandPool(device, frame->commandPool, 0);\n"
        "    VkCommandBufferBeginInfo cbbi = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};\n"
        "    r = vkBeginCommandBuffer(frame->commandBuffer, &cbbi);\n"
        "\n"
        "    VkClearValue clearValue = {0.002f, 0.003f, 0.009f, 1.0f};\n"
        "\n"
        "    const VkRenderPassBeginInfo rpassInfoFirst = {\n"
        "        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,\n"
        "        .clearValueCount = 1,\n"
        "        .pClearValues = &clearValue,\n"
        "        .renderArea = {{0, 0}, {WINDOW_WIDTH, WINDOW_HEIGHT}},\n"
        "        .renderPass =  frame->renderPass,\n"
        "        .framebuffer = frame->frameBuffer \n"
        "    };\n"
        "\n"
        "    vkCmdBeginRenderPass(frame->commandBuffer, &rpassInfoFirst, VK_SUBPASS_CONTENTS_INLINE);\n"
        "\n"
        "    vkCmdBindPipeline(frame->commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines[R_OBJ_PIPELINE]);\n"
        "\n"
        "    vkCmdBindVertexBuffers(\n"
        "            frame->commandBuffer, 0, 1, vertexBlock->vBuffer, &vertexBlock->vOffset);\n"
        "\n"
        "    vkCmdDraw(frame->commandBuffer, 3, 1, 0, 0);\n"
        "\n"
        "    vkCmdEndRenderPass(frame->commandBuffer);\n"
        "\n"
        "    r = vkEndCommandBuffer(frame->commandBuffer);\n"
        "    assert ( VK_SUCCESS == r );\n"
        "}\n";

    writeModule(renderSource, renderHeader, "r_render");
    writeModule(pipelineSource, pipelineHeader, "r_pipeline");
    writeModule(commandsSource, commandsHeader, "r_commands");
}

void buildInputFiles(void)
{
    printf("Building Input files...\n");
    const char* inHeader = 
    "#ifndef I_INPUT_H\n"
    "#define I_INPUT_H\n"
    "\n"
    "#include <stdint.h>\n"
    "\n"
    "typedef uint32_t I_EventData;\n"
    "\n"
    "typedef enum {\n"
    "    i_Keydown,\n"
    "    i_Keyup,\n"
    "} I_EventType;\n"
    "\n"
    "typedef struct i_event {\n"
    "    I_EventType type;\n"
    "    I_EventData data;\n"
    "} I_Event;\n"
    "\n"
    "void i_Init(void);\n"
    "void i_GetEvents(void);\n"
    "void i_ProcessEvents(void);\n"
    "void i_CleanUp(void);\n"
    "\n"
    "#endif /* end of include guard: I_INPUT_H */\n";

    const char* inSource = 
    "#include \"i_input.h\"\n"
    "#include \"d_display.h\"\n"
    "#include \"def.h\"\n"
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <xcb/xcb.h>\n"
    "#include <xcb/xcb_event.h>\n"
    "#include <xcb/xcb_keysyms.h>\n"
    "#include <xcb/xcb_util.h>\n"
    "#include <X11/keysym.h>\n"
    "\n"
    "#define MAX_EVENTS 32\n"
    "\n"
    "static xcb_key_symbols_t* pXcbKeySymbols;\n"
    "\n"
    "static I_Event events[MAX_EVENTS];\n"
    "static int     eventHead;\n"
    "static int     eventTail;\n"
    "\n"
    "static I_EventData getKeyCode(xcb_key_press_event_t* event)\n"
    "{\n"
    "    // XCB documentation is fucking horrible. fucking last parameter is called col. wtf? \n"
    "    // no clue what that means. ZERO documentation on this function. trash.\n"
    "    xcb_keysym_t keySym = xcb_key_symbols_get_keysym(pXcbKeySymbols, event->detail, 0); \n"
    "    switch (keySym)\n"
    "    {\n"
    "        case XK_w:      return KEY_W;\n"
    "        case XK_a:      return KEY_A;\n"
    "        case XK_s:      return KEY_S;\n"
    "        case XK_d:      return KEY_D;\n"
    "        case XK_space:  return KEY_SPACE;\n"
    "        case XK_Escape: return KEY_ESC;\n"
    "        default: return 0;\n"
    "    }\n"
    "}\n"
    "\n"
    "static void postEvent(I_Event event)\n"
    "{\n"
    "    events[eventHead] = event;\n"
    "    eventHead = (eventHead + 1) % MAX_EVENTS;\n"
    "}\n"
    "\n"
    "void i_Init(void)\n"
    "{\n"
    "    pXcbKeySymbols = xcb_key_symbols_alloc(d_XcbWindow.connection);\n"
    "}\n"
    "\n"
    "void i_GetEvents(void)\n"
    "{\n"
    "    xcb_generic_event_t* xEvent = NULL;\n"
    "    while ((xEvent = xcb_poll_for_event(d_XcbWindow.connection)))\n"
    "    {\n"
    "        I_Event event;\n"
    "        switch (XCB_EVENT_RESPONSE_TYPE(xEvent))\n"
    "        {\n"
    "            case XCB_KEY_PRESS: \n"
    "                {\n"
    "//                xcb_key_press_event_t* xPress = (xcb_key_press_event_t*)xEvent;\n"
    "//                printf(\"Press: time: %d\\n\", xPress->time);\n"
    "\n"
    "                event.type = i_Keydown; \n"
    "                I_EventData keyCode = getKeyCode((xcb_key_press_event_t*)xEvent);\n"
    "                if (keyCode == 0) goto end;\n"
    "                event.data = keyCode;\n"
    "                break;\n"
    "                }\n"
    "            case XCB_KEY_RELEASE: \n"
    "                // bunch of extra stuff here dedicated to detecting autrepeats\n"
    "                // the idea is that if a key-release event is detected, followed\n"
    "                // by an immediate keypress of the same key, its an autorepeat.\n"
    "                // its unclear to me whether very rapidly hitting a key could\n"
    "                // result in the same thing, and wheter it is worthwhile \n"
    "                // accounting for that\n"
    "                {\n"
    "//                xcb_key_press_event_t* xPress = (xcb_key_press_event_t*)xEvent;\n"
    "//                printf(\"Release: time: %d\\n\", xPress->time);\n"
    "\n"
    "                event.type = i_Keyup;\n"
    "                I_EventData keyCode = getKeyCode((xcb_key_press_event_t*)xEvent);\n"
    "                if (keyCode == 0) goto end;\n"
    "                event.data = keyCode;\n"
    "                // need to see if this is actually an auto repeat\n"
    "                xcb_generic_event_t* next = xcb_poll_for_event(d_XcbWindow.connection);\n"
    "                if (next) \n"
    "                {\n"
    "                    I_Event event2;\n"
    "                    uint8_t type = XCB_EVENT_RESPONSE_TYPE(next);\n"
    "                    event2.data = getKeyCode((xcb_key_press_event_t*)next);\n"
    "                    if (type == XCB_KEY_PRESS \n"
    "                            && event2.data == event.data)\n"
    "                    {\n"
    "                        // is likely an autorepeate\n"
    "                        free(next);\n"
    "                        goto end;\n"
    "                    }\n"
    "                    else\n"
    "                    {\n"
    "                        event2.type = i_Keyup;\n"
    "                        postEvent(event);\n"
    "                        event = event2;\n"
    "                        free(next);\n"
    "                    }\n"
    "                    break;\n"
    "                }\n"
    "                break;\n"
    "                }\n"
    "            default: return;\n"
    "        }\n"
    "        postEvent(event);\n"
    "end:\n"
    "        free(xEvent);\n"
    "    }\n"
    "    // to do\n"
    "}\n"
    "\n"
    "void i_ProcessEvents(void)\n"
    "{\n"
    "    I_Event* event;\n"
    "    for ( ; eventTail != eventHead; eventTail = (eventTail + 1) % MAX_EVENTS) \n"
    "    {\n"
    "        event = &events[eventTail];   \n"
    "    }\n"
    "}\n"
    "\n"
    "void i_CleanUp(void)\n"
    "{\n"
    "    xcb_key_symbols_free(pXcbKeySymbols);\n"
    "}\n";

    writeModule(inSource, inHeader, "i_input");
}

int main(int argc, char *argv[])
{
    char input[STR_LEN];
    memset(input, 0, STR_LEN);
    char* ret;
    printf("The stone age has begun!\n");
    printf("Enter a name for the executable.\n");
    ret = fgets(input, STR_LEN, stdin);
    assert(ret);
    strncpy(parms.name, input, strlen(input));
    memset(input, 0, STR_LEN);
    printf("Which modules would you like to create?\n");
    printf("a: audio \tv: video\tr: render \ti: input \tspace: all\n");
    ret = fgets(input, STR_LEN, stdin);
    assert(ret);
    for (int i = 0; i < STR_LEN; i++) 
    {
        switch (input[i]) 
        {
            case 'a': parms.audio  = true; break;
            case 'v': parms.video  = true; break;
            case 'r': parms.render = true; break;
            case 'i': parms.input  = true; break;
            case ' ': parms.input  = parms.render = parms.audio = parms.video = true;
        }
    }
    buildDirectories();
    buildMain();
    buildGlobals();
    buildMakefile();
    if (parms.audio)
        buildAudioFiles();
    if (parms.video)
    {
        buildDisplayFiles();
        buildVideoFiles();
        buildShaders();
    }
    if (parms.render) 
        buildRenderFiles();
    if (parms.input)
        buildInputFiles();
    return 0;
}
