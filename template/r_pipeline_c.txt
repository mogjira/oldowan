    "#include \"r_pipeline.h\"\n"
    "#include \"v_video.h\"\n"
    "#include \"r_render.h\"\n"
    "#include \"m_math.h\"\n"
    "#include \"def.h\"\n"
    "#include <stdio.h>\n"
    "#include <assert.h>\n"
    "#include <vulkan/vulkan_core.h>\n"
    "\n"
    "VkPipeline      pipelines[MAX_PIPELINES];\n"
    "VkDescriptorSet descriptorSets[MAX_DESCRIPTOR_SETS];\n"
    "static VkPipelineLayout pipelineLayoutGeometry;\n"
    "VkPipelineLayout pipelineLayoutPostProcess;\n"
    "static VkDescriptorSetLayout descriptorSetLayoutEmpty; \n"
    "static VkDescriptorSetLayout descriptorSetLayoutPostProcess; \n"
    "static VkDescriptorPool      descriptorPool;\n"
    "\n"
    "enum shaderStageType { VERT, FRAG };\n"
    "\n"
    "#define PIPELINE_COUNT 1\n"
    "#define DESCRIPTOR_SET_COUNT 1\n"
    "\n"
    "static void initShaderModule(const char* filepath, VkShaderModule* module)\n"
    "{\n"
    "    VkResult r;\n"
    "    int fr;\n"
    "    FILE* fp;\n"
    "    fp = fopen(filepath, \"rb\");\n"
    "    fr = fseek(fp, 0, SEEK_END);\n"
    "    assert( fr == 0 ); // success \n"
    "    size_t codeSize = ftell(fp);\n"
    "    rewind(fp);\n"
    "\n"
    "    unsigned char code[codeSize];\n"
    "    fread(code, 1, codeSize, fp);\n"
    "    fclose(fp);\n"
    "\n"
    "    const VkShaderModuleCreateInfo shaderInfo = {\n"
    "        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n"
    "        .codeSize = codeSize,\n"
    "        .pCode = (uint32_t*)code,\n"
    "    };\n"
    "\n"
    "    r = vkCreateShaderModule(device, &shaderInfo, NULL, module);\n"
    "    assert( VK_SUCCESS == r );\n"
    "}\n"
    "\n"
    "void initDescriptorSets(void)\n"
    "{\n"
    "    VkResult r;\n"
    "\n"
    "    VkDescriptorSetLayoutCreateInfo layoutInfo = {\n"
    "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,\n"
    "        .bindingCount = 0,\n"
    "        .pBindings = NULL\n"
    "    };\n"
    "\n"
    "    r = vkCreateDescriptorSetLayout(device, &layoutInfo, NULL, &descriptorSetLayoutEmpty);\n"
    "    assert( VK_SUCCESS == r );\n"
    "\n"
    "    VkDescriptorSetLayoutBinding textureBinding = {\n"
    "        .binding = 0,\n"
    "        .descriptorCount = 1,\n"
    "        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n"
    "        .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,\n"
    "        .pImmutableSamplers = NULL, // no one really seems to use these\n"
    "    };\n"
    "\n"
    "    layoutInfo.bindingCount = 1;\n"
    "    layoutInfo.pBindings = &textureBinding;\n"
    "\n"
    "    r = vkCreateDescriptorSetLayout(device, &layoutInfo, NULL, &descriptorSetLayoutPostProcess);\n"
    "    assert( VK_SUCCESS == r );\n"
    "\n"
    "    VkDescriptorPoolSize poolSize = {\n"
    "        .descriptorCount = 1,\n"
    "        .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\n"
    "    };\n"
    "\n"
    "    VkDescriptorPoolCreateInfo poolInfo = {\n"
    "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,\n"
    "        .maxSets = 1,\n"
    "        .poolSizeCount = 1,\n"
    "        // odd name. not the sizes of pools, but the numbers of descriptors\n"
    "        // of a certain type that can be created from the pool\n"
    "        .pPoolSizes = &poolSize, \n"
    "    };\n"
    "\n"
    "    vkCreateDescriptorPool(device, &poolInfo, NULL, &descriptorPool);\n"
    "\n"
    "    VkDescriptorSetAllocateInfo allocInfo = {\n"
    "        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,\n"
    "        .descriptorPool = descriptorPool,\n"
    "        .descriptorSetCount = DESCRIPTOR_SET_COUNT,\n"
    "        .pSetLayouts = &descriptorSetLayoutPostProcess,\n"
    "    };\n"
    "\n"
    "    vkAllocateDescriptorSets(device, &allocInfo, descriptorSets);\n"
    "}\n"
    "\n"
    "void initDescriptors(void)\n"
    "{\n"
    "    VkDescriptorImageInfo imageInfo = {\n"
    "        .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n"
    "        .imageView = offscreenFrameBuffer.image.view,\n"
    "        .sampler = offscreenFrameBuffer.image.sampler\n"
    "    };\n"
    "\n"
    "    VkWriteDescriptorSet writeImages = {\n"
    "        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n"
    "        .dstArrayElement = 0,\n"
    "        .dstSet = descriptorSets[R_POST_PROC_DESCRIPTOR_SET],\n"
    "        .dstBinding = 0,\n"
    "        .descriptorCount = 1,\n"
    "        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n"
    "        .pImageInfo = &imageInfo\n"
    "    };\n"
    "\n"
    "    vkUpdateDescriptorSets(device, 1, &writeImages, 0, NULL);\n"
    "}\n"
    "\n"
    "static void initPipelineLayouts(void)\n"
    "{\n"
    "    VkResult r;\n"
    "    VkPipelineLayoutCreateInfo info = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n"
    "        .pNext = NULL,\n"
    "        .flags = 0,\n"
    "        .setLayoutCount = 1, // ?\n"
    "        .pSetLayouts = &descriptorSetLayoutEmpty,\n"
    "        .pushConstantRangeCount = 0,\n"
    "        .pPushConstantRanges = NULL\n"
    "    };\n"
    "\n"
    "    r = vkCreatePipelineLayout(device, &info, NULL, &pipelineLayoutGeometry);\n"
    "    assert( VK_SUCCESS == r );\n"
    "}\n"
    "\n"
    "void initPipelines(void)\n"
    "{\n"
    "    initPipelineLayouts();\n"
    "\n"
    "    VkShaderModule vertModule;\n"
    "    VkShaderModule fragModule;\n"
    "\n"
    "    initShaderModule(\"shaders/spv/default-vert.spv\", &vertModule);\n"
    "    initShaderModule(\"shaders/spv/default-frag.spv\", &fragModule);\n"
    "\n"
    "    const VkSpecializationInfo shaderSpecialInfo = {\n"
    "        // TODO\n"
    "    };\n"
    "\n"
    "    const VkPipelineShaderStageCreateInfo shaderStages[2] = {\n"
    "        [0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n"
    "        [0].stage = VK_SHADER_STAGE_VERTEX_BIT,\n"
    "        [0].module = vertModule,\n"
    "        [0].pName = \"main\",\n"
    "        [0].pSpecializationInfo = NULL,\n"
    "        [1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,\n"
    "        [1].stage = VK_SHADER_STAGE_FRAGMENT_BIT,\n"
    "        [1].module = fragModule,\n"
    "        [1].pName = \"main\",\n"
    "        [1].pSpecializationInfo = NULL,\n"
    "    }; // vert and frag\n"
    "\n"
    "    const VkVertexInputBindingDescription bindingDescription = {\n"
    "        .binding = 0,\n"
    "        .stride  = sizeof(Vertex), // all our verts will be 2D\n"
    "        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX\n"
    "    };\n"
    "\n"
    "    const VkVertexInputAttributeDescription positionAttributeDescription = {\n"
    "        .binding = 0,\n"
    "        .location = 0, \n"
    "        .format = VK_FORMAT_R32G32_SFLOAT,\n"
    "        .offset = 0,\n"
    "    };\n"
    "\n"
    "    const VkVertexInputAttributeDescription colorAttributeDescription = {\n"
    "        .binding = 0,\n"
    "        .location = 1, \n"
    "        .format = VK_FORMAT_R32G32B32_SFLOAT,\n"
    "        .offset = sizeof(Vec2),\n"
    "    };\n"
    "\n"
    "    VkVertexInputAttributeDescription vAttrDescs[2] = {\n"
    "        positionAttributeDescription, colorAttributeDescription\n"
    "    };\n"
    "\n"
    "    const VkPipelineVertexInputStateCreateInfo vertexInput = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,\n"
    "        .vertexBindingDescriptionCount = 1,\n"
    "        .pVertexBindingDescriptions = &bindingDescription,\n"
    "        .vertexAttributeDescriptionCount = 2,\n"
    "        .pVertexAttributeDescriptions = vAttrDescs \n"
    "    };\n"
    "\n"
    "    const VkPipelineInputAssemblyStateCreateInfo inputAssembly = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,\n"
    "        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,\n"
    "        .primitiveRestartEnable = VK_FALSE // applies only to index calls\n"
    "    };\n"
    "\n"
    "    const VkViewport viewport = {\n"
    "        .height = WINDOW_HEIGHT,\n"
    "        .width = WINDOW_WIDTH,\n"
    "        .x = 0,\n"
    "        .y = 0,\n"
    "        .minDepth = 0.0,\n"
    "        .maxDepth = 1.0\n"
    "    };\n"
    "\n"
    "    const VkRect2D scissor = {\n"
    "        .extent = {WINDOW_WIDTH, WINDOW_HEIGHT},\n"
    "        .offset = {0, 0}\n"
    "    };\n"
    "\n"
    "    const VkPipelineViewportStateCreateInfo viewportState = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,\n"
    "        .scissorCount = 1,\n"
    "        .pScissors = &scissor,\n"
    "        .viewportCount = 1,\n"
    "        .pViewports = &viewport,\n"
    "    };\n"
    "\n"
    "    const VkPipelineRasterizationStateCreateInfo rasterizationState = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,\n"
    "        .depthClampEnable = VK_FALSE, // dunno\n"
    "        .rasterizerDiscardEnable = VK_FALSE, // actually discards everything\n"
    "        .polygonMode = VK_POLYGON_MODE_FILL,\n"
    "        .cullMode = VK_CULL_MODE_BACK_BIT,\n"
    "        .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,\n"
    "        .depthBiasEnable = VK_FALSE,\n"
    "        .lineWidth = 1.0\n"
    "    };\n"
    "\n"
    "    const VkPipelineMultisampleStateCreateInfo multisampleState = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,\n"
    "        .sampleShadingEnable = VK_FALSE,\n"
    "        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT\n"
    "        // TODO: alot more settings here. more to look into\n"
    "    };\n"
    "\n"
    "    const VkPipelineColorBlendAttachmentState attachmentState = {\n"
    "        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | \n"
    "            VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT, /* need this to actually\n"
    "                                                                    write anything to the\n"
    "                                                                    framebuffer */\n"
    "        .blendEnable = VK_FALSE, // no blending for now\n"
    "        .srcColorBlendFactor = 0,\n"
    "        .dstColorBlendFactor = 0,\n"
    "        .colorBlendOp = 0,\n"
    "        .srcAlphaBlendFactor = 0,\n"
    "        .dstAlphaBlendFactor = 0,\n"
    "        .alphaBlendOp = 0,\n"
    "    };\n"
    "\n"
    "    const VkPipelineColorBlendStateCreateInfo colorBlendState = {\n"
    "        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,\n"
    "        .logicOpEnable = VK_FALSE, // only for integer framebuffer formats\n"
    "        .logicOp = 0,\n"
    "        .attachmentCount = 1,\n"
    "        .pAttachments = &attachmentState /* must have independentBlending device   \n"
    "            feature enabled for these to be different. each entry would correspond \n"
    "            to the blending for a different framebuffer. */\n"
    "    };\n"
    "\n"
    "    const VkGraphicsPipelineCreateInfo pipelineInfo = {\n"
    "        .basePipelineIndex = 0, // not used\n"
    "        .basePipelineHandle = 0,\n"
    "        .subpass = 0, // which subpass in the renderpass do we use this pipeline with\n"
    "        .renderPass = swapchainRenderPass,\n"
    "        .layout = pipelineLayoutGeometry,\n"
    "        .pDynamicState = NULL,\n"
    "        .pColorBlendState = &colorBlendState,\n"
    "        .pDepthStencilState = NULL,\n"
    "        .pMultisampleState = &multisampleState,\n"
    "        .pRasterizationState = &rasterizationState,\n"
    "        .pViewportState = &viewportState,\n"
    "        .pTessellationState = NULL, // may be able to do splines with this\n"
    "        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n"
    "        .flags = 0,\n"
    "        .stageCount = sizeof(shaderStages) / sizeof(shaderStages[0]),\n"
    "        .pStages = shaderStages,\n"
    "        .pVertexInputState = &vertexInput,\n"
    "        .pInputAssemblyState = &inputAssembly,\n"
    "    };\n"
    "\n"
    "    VkGraphicsPipelineCreateInfo infos[PIPELINE_COUNT] = {pipelineInfo};\n"
    "\n"
    "    vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, PIPELINE_COUNT, infos, NULL, pipelines);\n"
    "\n"
    "    vkDestroyShaderModule(device, vertModule, NULL);\n"
    "    vkDestroyShaderModule(device, fragModule, NULL);\n"
    "    vkDestroyDescriptorSetLayout(device, descriptorSetLayoutEmpty, NULL);\n"
    "    vkDestroyDescriptorSetLayout(device, descriptorSetLayoutPostProcess, NULL);\n"
    "}\n"
    "\n"
    "void cleanUpPipelines()\n"
    "{\n"
    "    vkDestroyPipelineLayout(device, pipelineLayoutGeometry, NULL);\n"
    "    vkDestroyPipelineLayout(device, pipelineLayoutPostProcess, NULL);\n"
    "    for (int i = 0; i < PIPELINE_COUNT; i++) \n"
    "    {\n"
    "        vkDestroyPipeline(device, pipelines[i], NULL);\n"
    "    }\n"
    "    vkDestroyDescriptorPool(device, descriptorPool, NULL);\n"
    "}\n"
